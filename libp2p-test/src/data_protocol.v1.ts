// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.2
// source: src/data_protocol.v1.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "api.v1.data_protocol";

export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_DOCUMENT_CREATION_ERROR = 1,
  ERROR_CODE_DOCUMENT_RETRIEVAL_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_DOCUMENT_CREATION_ERROR":
      return ErrorCode.ERROR_CODE_DOCUMENT_CREATION_ERROR;
    case 2:
    case "ERROR_CODE_DOCUMENT_RETRIEVAL_ERROR":
      return ErrorCode.ERROR_CODE_DOCUMENT_RETRIEVAL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_DOCUMENT_CREATION_ERROR:
      return "ERROR_CODE_DOCUMENT_CREATION_ERROR";
    case ErrorCode.ERROR_CODE_DOCUMENT_RETRIEVAL_ERROR:
      return "ERROR_CODE_DOCUMENT_RETRIEVAL_ERROR";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BeepRequest {}

export interface CreateDocumentRequest {
  /** Document in JSON format. */
  payload: Uint8Array;
}

export interface BatchCreateDocumentRequest {
  /** List of create document requests. */
  requests: CreateDocumentRequest[];
}

export interface GetDocumentRequest {
  /** Scale encoded document ID. */
  documentId: Uint8Array;
  /** OPTIONAL - Document version. If none is provided, the latest document will be retrieved. */
  documentVersion?: number | undefined;
}

export interface BatchGetDocumentRequest {
  /** List of get document requests. */
  requests: BatchCreateDocumentRequest[];
}

export interface DataProtocolRequest {
  createDocumentRequest?: CreateDocumentRequest | undefined;
  batchCreateDocumentRequest?: BatchCreateDocumentRequest | undefined;
  getDocumentRequest?: GetDocumentRequest | undefined;
  batchGetDocumentRequest?: BatchGetDocumentRequest | undefined;
  /** TODO: Remove */
  beepRequest?: BeepRequest | undefined;
}

export interface BeepResponse {}

export interface CreateDocumentResponse {
  /** Document in JSON format. */
  payload?: Uint8Array | undefined;
  error?: DataProtocolError | undefined;
}

export interface BatchCreateDocumentResponse {
  responses: CreateDocumentResponse[];
}

export interface GetDocumentResponse {
  /** Document in JSON format. */
  payload?: Uint8Array | undefined;
  error?: DataProtocolError | undefined;
}

export interface BatchGetDocumentResponse {
  responses: GetDocumentResponse[];
}

export interface DataProtocolResponse {
  createDocumentResponse?: CreateDocumentResponse | undefined;
  batchCreateDocumentResponse?: BatchCreateDocumentResponse | undefined;
  getDocumentResponse?: GetDocumentResponse | undefined;
  batchGetDocumentResponse?: BatchGetDocumentResponse | undefined;
  /** TODO: Remove */
  beepResponse?: BeepResponse | undefined;
}

export interface DataProtocolError {
  error: string;
  code: ErrorCode;
}

function createBaseBeepRequest(): BeepRequest {
  return {};
}

export const BeepRequest = {
  encode(_: BeepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BeepRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BeepRequest {
    return {};
  },

  toJSON(_: BeepRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BeepRequest>, I>>(base?: I): BeepRequest {
    return BeepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BeepRequest>, I>>(_: I): BeepRequest {
    const message = createBaseBeepRequest();
    return message;
  },
};

function createBaseCreateDocumentRequest(): CreateDocumentRequest {
  return { payload: new Uint8Array(0) };
}

export const CreateDocumentRequest = {
  encode(
    message: CreateDocumentRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.payload.length !== 0) {
      writer.uint32(10).bytes(message.payload);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CreateDocumentRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDocumentRequest {
    return {
      payload: isSet(object.payload)
        ? bytesFromBase64(object.payload)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateDocumentRequest): unknown {
    const obj: any = {};
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDocumentRequest>, I>>(
    base?: I
  ): CreateDocumentRequest {
    return CreateDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDocumentRequest>, I>>(
    object: I
  ): CreateDocumentRequest {
    const message = createBaseCreateDocumentRequest();
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBatchCreateDocumentRequest(): BatchCreateDocumentRequest {
  return { requests: [] };
}

export const BatchCreateDocumentRequest = {
  encode(
    message: BatchCreateDocumentRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.requests) {
      CreateDocumentRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BatchCreateDocumentRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(
            CreateDocumentRequest.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateDocumentRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateDocumentRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateDocumentRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) =>
        CreateDocumentRequest.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateDocumentRequest>, I>>(
    base?: I
  ): BatchCreateDocumentRequest {
    return BatchCreateDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateDocumentRequest>, I>>(
    object: I
  ): BatchCreateDocumentRequest {
    const message = createBaseBatchCreateDocumentRequest();
    message.requests =
      object.requests?.map((e) => CreateDocumentRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDocumentRequest(): GetDocumentRequest {
  return { documentId: new Uint8Array(0), documentVersion: undefined };
}

export const GetDocumentRequest = {
  encode(
    message: GetDocumentRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.documentId.length !== 0) {
      writer.uint32(10).bytes(message.documentId);
    }
    if (message.documentVersion !== undefined) {
      writer.uint32(16).uint64(message.documentVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDocumentRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentId = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.documentVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentRequest {
    return {
      documentId: isSet(object.documentId)
        ? bytesFromBase64(object.documentId)
        : new Uint8Array(0),
      documentVersion: isSet(object.documentVersion)
        ? globalThis.Number(object.documentVersion)
        : undefined,
    };
  },

  toJSON(message: GetDocumentRequest): unknown {
    const obj: any = {};
    if (message.documentId.length !== 0) {
      obj.documentId = base64FromBytes(message.documentId);
    }
    if (message.documentVersion !== undefined) {
      obj.documentVersion = Math.round(message.documentVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocumentRequest>, I>>(
    base?: I
  ): GetDocumentRequest {
    return GetDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocumentRequest>, I>>(
    object: I
  ): GetDocumentRequest {
    const message = createBaseGetDocumentRequest();
    message.documentId = object.documentId ?? new Uint8Array(0);
    message.documentVersion = object.documentVersion ?? undefined;
    return message;
  },
};

function createBaseBatchGetDocumentRequest(): BatchGetDocumentRequest {
  return { requests: [] };
}

export const BatchGetDocumentRequest = {
  encode(
    message: BatchGetDocumentRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.requests) {
      BatchCreateDocumentRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BatchGetDocumentRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(
            BatchCreateDocumentRequest.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetDocumentRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) =>
            BatchCreateDocumentRequest.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: BatchGetDocumentRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) =>
        BatchCreateDocumentRequest.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGetDocumentRequest>, I>>(
    base?: I
  ): BatchGetDocumentRequest {
    return BatchGetDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGetDocumentRequest>, I>>(
    object: I
  ): BatchGetDocumentRequest {
    const message = createBaseBatchGetDocumentRequest();
    message.requests =
      object.requests?.map((e) => BatchCreateDocumentRequest.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDataProtocolRequest(): DataProtocolRequest {
  return {
    createDocumentRequest: undefined,
    batchCreateDocumentRequest: undefined,
    getDocumentRequest: undefined,
    batchGetDocumentRequest: undefined,
    beepRequest: undefined,
  };
}

export const DataProtocolRequest = {
  encode(
    message: DataProtocolRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.createDocumentRequest !== undefined) {
      CreateDocumentRequest.encode(
        message.createDocumentRequest,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.batchCreateDocumentRequest !== undefined) {
      BatchCreateDocumentRequest.encode(
        message.batchCreateDocumentRequest,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.getDocumentRequest !== undefined) {
      GetDocumentRequest.encode(
        message.getDocumentRequest,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.batchGetDocumentRequest !== undefined) {
      BatchGetDocumentRequest.encode(
        message.batchGetDocumentRequest,
        writer.uint32(34).fork()
      ).ldelim();
    }
    if (message.beepRequest !== undefined) {
      BeepRequest.encode(
        message.beepRequest,
        writer.uint32(82).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataProtocolRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataProtocolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createDocumentRequest = CreateDocumentRequest.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.batchCreateDocumentRequest =
            BatchCreateDocumentRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.getDocumentRequest = GetDocumentRequest.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.batchGetDocumentRequest = BatchGetDocumentRequest.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.beepRequest = BeepRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataProtocolRequest {
    return {
      createDocumentRequest: isSet(object.createDocumentRequest)
        ? CreateDocumentRequest.fromJSON(object.createDocumentRequest)
        : undefined,
      batchCreateDocumentRequest: isSet(object.batchCreateDocumentRequest)
        ? BatchCreateDocumentRequest.fromJSON(object.batchCreateDocumentRequest)
        : undefined,
      getDocumentRequest: isSet(object.getDocumentRequest)
        ? GetDocumentRequest.fromJSON(object.getDocumentRequest)
        : undefined,
      batchGetDocumentRequest: isSet(object.batchGetDocumentRequest)
        ? BatchGetDocumentRequest.fromJSON(object.batchGetDocumentRequest)
        : undefined,
      beepRequest: isSet(object.beepRequest)
        ? BeepRequest.fromJSON(object.beepRequest)
        : undefined,
    };
  },

  toJSON(message: DataProtocolRequest): unknown {
    const obj: any = {};
    if (message.createDocumentRequest !== undefined) {
      obj.createDocumentRequest = CreateDocumentRequest.toJSON(
        message.createDocumentRequest
      );
    }
    if (message.batchCreateDocumentRequest !== undefined) {
      obj.batchCreateDocumentRequest = BatchCreateDocumentRequest.toJSON(
        message.batchCreateDocumentRequest
      );
    }
    if (message.getDocumentRequest !== undefined) {
      obj.getDocumentRequest = GetDocumentRequest.toJSON(
        message.getDocumentRequest
      );
    }
    if (message.batchGetDocumentRequest !== undefined) {
      obj.batchGetDocumentRequest = BatchGetDocumentRequest.toJSON(
        message.batchGetDocumentRequest
      );
    }
    if (message.beepRequest !== undefined) {
      obj.beepRequest = BeepRequest.toJSON(message.beepRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataProtocolRequest>, I>>(
    base?: I
  ): DataProtocolRequest {
    return DataProtocolRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataProtocolRequest>, I>>(
    object: I
  ): DataProtocolRequest {
    const message = createBaseDataProtocolRequest();
    message.createDocumentRequest =
      object.createDocumentRequest !== undefined &&
      object.createDocumentRequest !== null
        ? CreateDocumentRequest.fromPartial(object.createDocumentRequest)
        : undefined;
    message.batchCreateDocumentRequest =
      object.batchCreateDocumentRequest !== undefined &&
      object.batchCreateDocumentRequest !== null
        ? BatchCreateDocumentRequest.fromPartial(
            object.batchCreateDocumentRequest
          )
        : undefined;
    message.getDocumentRequest =
      object.getDocumentRequest !== undefined &&
      object.getDocumentRequest !== null
        ? GetDocumentRequest.fromPartial(object.getDocumentRequest)
        : undefined;
    message.batchGetDocumentRequest =
      object.batchGetDocumentRequest !== undefined &&
      object.batchGetDocumentRequest !== null
        ? BatchGetDocumentRequest.fromPartial(object.batchGetDocumentRequest)
        : undefined;
    message.beepRequest =
      object.beepRequest !== undefined && object.beepRequest !== null
        ? BeepRequest.fromPartial(object.beepRequest)
        : undefined;
    return message;
  },
};

function createBaseBeepResponse(): BeepResponse {
  return {};
}

export const BeepResponse = {
  encode(
    _: BeepResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BeepResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BeepResponse {
    return {};
  },

  toJSON(_: BeepResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BeepResponse>, I>>(
    base?: I
  ): BeepResponse {
    return BeepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BeepResponse>, I>>(
    _: I
  ): BeepResponse {
    const message = createBaseBeepResponse();
    return message;
  },
};

function createBaseCreateDocumentResponse(): CreateDocumentResponse {
  return { payload: undefined, error: undefined };
}

export const CreateDocumentResponse = {
  encode(
    message: CreateDocumentResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.payload !== undefined) {
      writer.uint32(10).bytes(message.payload);
    }
    if (message.error !== undefined) {
      DataProtocolError.encode(
        message.error,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CreateDocumentResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = DataProtocolError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDocumentResponse {
    return {
      payload: isSet(object.payload)
        ? bytesFromBase64(object.payload)
        : undefined,
      error: isSet(object.error)
        ? DataProtocolError.fromJSON(object.error)
        : undefined,
    };
  },

  toJSON(message: CreateDocumentResponse): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.error !== undefined) {
      obj.error = DataProtocolError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDocumentResponse>, I>>(
    base?: I
  ): CreateDocumentResponse {
    return CreateDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDocumentResponse>, I>>(
    object: I
  ): CreateDocumentResponse {
    const message = createBaseCreateDocumentResponse();
    message.payload = object.payload ?? undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? DataProtocolError.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseBatchCreateDocumentResponse(): BatchCreateDocumentResponse {
  return { responses: [] };
}

export const BatchCreateDocumentResponse = {
  encode(
    message: BatchCreateDocumentResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.responses) {
      CreateDocumentResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BatchCreateDocumentResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responses.push(
            CreateDocumentResponse.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateDocumentResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => CreateDocumentResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateDocumentResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) =>
        CreateDocumentResponse.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateDocumentResponse>, I>>(
    base?: I
  ): BatchCreateDocumentResponse {
    return BatchCreateDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateDocumentResponse>, I>>(
    object: I
  ): BatchCreateDocumentResponse {
    const message = createBaseBatchCreateDocumentResponse();
    message.responses =
      object.responses?.map((e) => CreateDocumentResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDocumentResponse(): GetDocumentResponse {
  return { payload: undefined, error: undefined };
}

export const GetDocumentResponse = {
  encode(
    message: GetDocumentResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.payload !== undefined) {
      writer.uint32(10).bytes(message.payload);
    }
    if (message.error !== undefined) {
      DataProtocolError.encode(
        message.error,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDocumentResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = DataProtocolError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentResponse {
    return {
      payload: isSet(object.payload)
        ? bytesFromBase64(object.payload)
        : undefined,
      error: isSet(object.error)
        ? DataProtocolError.fromJSON(object.error)
        : undefined,
    };
  },

  toJSON(message: GetDocumentResponse): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.error !== undefined) {
      obj.error = DataProtocolError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocumentResponse>, I>>(
    base?: I
  ): GetDocumentResponse {
    return GetDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocumentResponse>, I>>(
    object: I
  ): GetDocumentResponse {
    const message = createBaseGetDocumentResponse();
    message.payload = object.payload ?? undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? DataProtocolError.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseBatchGetDocumentResponse(): BatchGetDocumentResponse {
  return { responses: [] };
}

export const BatchGetDocumentResponse = {
  encode(
    message: BatchGetDocumentResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.responses) {
      GetDocumentResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BatchGetDocumentResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responses.push(
            GetDocumentResponse.decode(reader, reader.uint32())
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetDocumentResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => GetDocumentResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchGetDocumentResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) =>
        GetDocumentResponse.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGetDocumentResponse>, I>>(
    base?: I
  ): BatchGetDocumentResponse {
    return BatchGetDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGetDocumentResponse>, I>>(
    object: I
  ): BatchGetDocumentResponse {
    const message = createBaseBatchGetDocumentResponse();
    message.responses =
      object.responses?.map((e) => GetDocumentResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDataProtocolResponse(): DataProtocolResponse {
  return {
    createDocumentResponse: undefined,
    batchCreateDocumentResponse: undefined,
    getDocumentResponse: undefined,
    batchGetDocumentResponse: undefined,
    beepResponse: undefined,
  };
}

export const DataProtocolResponse = {
  encode(
    message: DataProtocolResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.createDocumentResponse !== undefined) {
      CreateDocumentResponse.encode(
        message.createDocumentResponse,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.batchCreateDocumentResponse !== undefined) {
      BatchCreateDocumentResponse.encode(
        message.batchCreateDocumentResponse,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.getDocumentResponse !== undefined) {
      GetDocumentResponse.encode(
        message.getDocumentResponse,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.batchGetDocumentResponse !== undefined) {
      BatchGetDocumentResponse.encode(
        message.batchGetDocumentResponse,
        writer.uint32(34).fork()
      ).ldelim();
    }
    if (message.beepResponse !== undefined) {
      BeepResponse.encode(
        message.beepResponse,
        writer.uint32(82).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DataProtocolResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataProtocolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createDocumentResponse = CreateDocumentResponse.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.batchCreateDocumentResponse =
            BatchCreateDocumentResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.getDocumentResponse = GetDocumentResponse.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.batchGetDocumentResponse = BatchGetDocumentResponse.decode(
            reader,
            reader.uint32()
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.beepResponse = BeepResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataProtocolResponse {
    return {
      createDocumentResponse: isSet(object.createDocumentResponse)
        ? CreateDocumentResponse.fromJSON(object.createDocumentResponse)
        : undefined,
      batchCreateDocumentResponse: isSet(object.batchCreateDocumentResponse)
        ? BatchCreateDocumentResponse.fromJSON(
            object.batchCreateDocumentResponse
          )
        : undefined,
      getDocumentResponse: isSet(object.getDocumentResponse)
        ? GetDocumentResponse.fromJSON(object.getDocumentResponse)
        : undefined,
      batchGetDocumentResponse: isSet(object.batchGetDocumentResponse)
        ? BatchGetDocumentResponse.fromJSON(object.batchGetDocumentResponse)
        : undefined,
      beepResponse: isSet(object.beepResponse)
        ? BeepResponse.fromJSON(object.beepResponse)
        : undefined,
    };
  },

  toJSON(message: DataProtocolResponse): unknown {
    const obj: any = {};
    if (message.createDocumentResponse !== undefined) {
      obj.createDocumentResponse = CreateDocumentResponse.toJSON(
        message.createDocumentResponse
      );
    }
    if (message.batchCreateDocumentResponse !== undefined) {
      obj.batchCreateDocumentResponse = BatchCreateDocumentResponse.toJSON(
        message.batchCreateDocumentResponse
      );
    }
    if (message.getDocumentResponse !== undefined) {
      obj.getDocumentResponse = GetDocumentResponse.toJSON(
        message.getDocumentResponse
      );
    }
    if (message.batchGetDocumentResponse !== undefined) {
      obj.batchGetDocumentResponse = BatchGetDocumentResponse.toJSON(
        message.batchGetDocumentResponse
      );
    }
    if (message.beepResponse !== undefined) {
      obj.beepResponse = BeepResponse.toJSON(message.beepResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataProtocolResponse>, I>>(
    base?: I
  ): DataProtocolResponse {
    return DataProtocolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataProtocolResponse>, I>>(
    object: I
  ): DataProtocolResponse {
    const message = createBaseDataProtocolResponse();
    message.createDocumentResponse =
      object.createDocumentResponse !== undefined &&
      object.createDocumentResponse !== null
        ? CreateDocumentResponse.fromPartial(object.createDocumentResponse)
        : undefined;
    message.batchCreateDocumentResponse =
      object.batchCreateDocumentResponse !== undefined &&
      object.batchCreateDocumentResponse !== null
        ? BatchCreateDocumentResponse.fromPartial(
            object.batchCreateDocumentResponse
          )
        : undefined;
    message.getDocumentResponse =
      object.getDocumentResponse !== undefined &&
      object.getDocumentResponse !== null
        ? GetDocumentResponse.fromPartial(object.getDocumentResponse)
        : undefined;
    message.batchGetDocumentResponse =
      object.batchGetDocumentResponse !== undefined &&
      object.batchGetDocumentResponse !== null
        ? BatchGetDocumentResponse.fromPartial(object.batchGetDocumentResponse)
        : undefined;
    message.beepResponse =
      object.beepResponse !== undefined && object.beepResponse !== null
        ? BeepResponse.fromPartial(object.beepResponse)
        : undefined;
    return message;
  },
};

function createBaseDataProtocolError(): DataProtocolError {
  return { error: "", code: 0 };
}

export const DataProtocolError = {
  encode(
    message: DataProtocolError,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataProtocolError {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataProtocolError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataProtocolError {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
    };
  },

  toJSON(message: DataProtocolError): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataProtocolError>, I>>(
    base?: I
  ): DataProtocolError {
    return DataProtocolError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataProtocolError>, I>>(
    object: I
  ): DataProtocolError {
    const message = createBaseDataProtocolError();
    message.error = object.error ?? "";
    message.code = object.code ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
