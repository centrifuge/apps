/**
 * Centrifuge OS Node API
 * Centrifuge OS Node API
 *
 * OpenAPI spec version: 2.0.0
 * Contact: hello@centrifuge.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request')
import http = require('http')
import Promise = require('bluebird')

let defaultBasePath = 'http://localhost:8082'

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = ['string', 'boolean', 'double', 'integer', 'long', 'float', 'number', 'any']

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType
    } else if (expectedType === 'Date') {
      return expectedType
    } else {
      if (enumsMap[expectedType]) {
        return expectedType
      }

      if (!typeMap[expectedType]) {
        return expectedType // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator
      if (discriminatorProperty == null) {
        return expectedType // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty] // use the type given in the discriminator
        } else {
          return expectedType // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data
    } else if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace('Array<', '') // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1) // Type> => Type
      let transformedData: any[] = []
      for (let index in data) {
        let date = data[index]
        transformedData.push(ObjectSerializer.serialize(date, subType))
      }
      return transformedData
    } else if (type === 'Date') {
      return data.toString()
    } else {
      if (enumsMap[type]) {
        return data
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap()
      let instance: { [index: string]: any } = {}
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index]
        instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type)
      }
      return instance
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type)
    if (data == undefined) {
      return data
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data
    } else if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace('Array<', '') // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1) // Type> => Type
      let transformedData: any[] = []
      for (let index in data) {
        let date = data[index]
        transformedData.push(ObjectSerializer.deserialize(date, subType))
      }
      return transformedData
    } else if (type === 'Date') {
      return new Date(data)
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data
      }

      if (!typeMap[type]) {
        // dont know the type
        return data
      }
      let instance = new typeMap[type]()
      let attributeTypes = typeMap[type].getAttributeTypeMap()
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index]
        instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type)
      }
      return instance
    }
  }
}

export class ConfigCentChainAccount {
  'id'?: string
  'secret'?: string
  'ss58Address'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'secret',
      baseName: 'secret',
      type: 'string',
    },
    {
      name: 'ss58Address',
      baseName: 'ss_58_address',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return ConfigCentChainAccount.attributeTypeMap
  }
}

export class CoreapiAccount {
  'centrifugeChainAccount'?: ConfigCentChainAccount
  'ethAccount'?: CoreapiEthAccount
  'ethDefaultAccountName'?: string
  'identityId'?: string
  'p2pKeyPair'?: CoreapiKeyPair
  'receiveEventNotificationEndpoint'?: string
  'signingKeyPair'?: CoreapiKeyPair

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'centrifugeChainAccount',
      baseName: 'centrifuge_chain_account',
      type: 'ConfigCentChainAccount',
    },
    {
      name: 'ethAccount',
      baseName: 'eth_account',
      type: 'CoreapiEthAccount',
    },
    {
      name: 'ethDefaultAccountName',
      baseName: 'eth_default_account_name',
      type: 'string',
    },
    {
      name: 'identityId',
      baseName: 'identity_id',
      type: 'string',
    },
    {
      name: 'p2pKeyPair',
      baseName: 'p2p_key_pair',
      type: 'CoreapiKeyPair',
    },
    {
      name: 'receiveEventNotificationEndpoint',
      baseName: 'receive_event_notification_endpoint',
      type: 'string',
    },
    {
      name: 'signingKeyPair',
      baseName: 'signing_key_pair',
      type: 'CoreapiKeyPair',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiAccount.attributeTypeMap
  }
}

export class CoreapiAccounts {
  'data'?: Array<CoreapiAccount>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<CoreapiAccount>',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiAccounts.attributeTypeMap
  }
}

export class CoreapiAttributeMapRequest extends null<String, CoreapiAttributeRequest> {
  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = []

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(CoreapiAttributeMapRequest.attributeTypeMap)
  }
}

export class CoreapiAttributeMapResponse extends null<String, CoreapiAttributeResponse> {
  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = []

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(CoreapiAttributeMapResponse.attributeTypeMap)
  }
}

export class CoreapiAttributeRequest {
  'monetaryValue'?: CoreapiMonetaryValue
  'type'?: CoreapiAttributeRequest.TypeEnum
  'value'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'monetaryValue',
      baseName: 'monetary_value',
      type: 'CoreapiMonetaryValue',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'CoreapiAttributeRequest.TypeEnum',
    },
    {
      name: 'value',
      baseName: 'value',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiAttributeRequest.attributeTypeMap
  }
}

export namespace CoreapiAttributeRequest {
  export enum TypeEnum {
    Integer = <any>'integer',
    Decimal = <any>'decimal',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
    Monetary = <any>'monetary',
  }
}
export class CoreapiAttributeResponse {
  'key'?: string
  'monetaryValue'?: CoreapiMonetaryValue
  'signedValue'?: CoreapiSignedValue
  'type'?: CoreapiAttributeResponse.TypeEnum
  'value'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'key',
      baseName: 'key',
      type: 'string',
    },
    {
      name: 'monetaryValue',
      baseName: 'monetary_value',
      type: 'CoreapiMonetaryValue',
    },
    {
      name: 'signedValue',
      baseName: 'signed_value',
      type: 'CoreapiSignedValue',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'CoreapiAttributeResponse.TypeEnum',
    },
    {
      name: 'value',
      baseName: 'value',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiAttributeResponse.attributeTypeMap
  }
}

export namespace CoreapiAttributeResponse {
  export enum TypeEnum {
    Integer = <any>'integer',
    Decimal = <any>'decimal',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
    Monetary = <any>'monetary',
  }
}
export class CoreapiDocumentResponse {
  'attributes'?: CoreapiAttributeMapResponse
  'data'?: any
  'header'?: CoreapiResponseHeader
  'scheme'?: CoreapiDocumentResponse.SchemeEnum

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributes',
      baseName: 'attributes',
      type: 'CoreapiAttributeMapResponse',
    },
    {
      name: 'data',
      baseName: 'data',
      type: 'any',
    },
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiResponseHeader',
    },
    {
      name: 'scheme',
      baseName: 'scheme',
      type: 'CoreapiDocumentResponse.SchemeEnum',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiDocumentResponse.attributeTypeMap
  }
}

export namespace CoreapiDocumentResponse {
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
export class CoreapiEthAccount {
  'address'?: string
  'key'?: string
  'password'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'address',
      baseName: 'address',
      type: 'string',
    },
    {
      name: 'key',
      baseName: 'key',
      type: 'string',
    },
    {
      name: 'password',
      baseName: 'password',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiEthAccount.attributeTypeMap
  }
}

export class CoreapiGenerateAccountPayload {
  'centrifugeChainAccount'?: ConfigCentChainAccount

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'centrifugeChainAccount',
      baseName: 'centrifuge_chain_account',
      type: 'ConfigCentChainAccount',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiGenerateAccountPayload.attributeTypeMap
  }
}

export class CoreapiKeyPair {
  'pub'?: string
  'pvt'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'pub',
      baseName: 'pub',
      type: 'string',
    },
    {
      name: 'pvt',
      baseName: 'pvt',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiKeyPair.attributeTypeMap
  }
}

export class CoreapiMintNFTOnCCRequest {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   */
  'depositAddress'?: string
  'documentId'?: string
  'proofFields'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'depositAddress',
      baseName: 'deposit_address',
      type: 'string',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'proofFields',
      baseName: 'proof_fields',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiMintNFTOnCCRequest.attributeTypeMap
  }
}

export class CoreapiMintNFTOnCCResponse {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   */
  'depositAddress'?: string
  'documentId'?: string
  'header'?: CoreapiNFTResponseHeader
  'registryAddress'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'depositAddress',
      baseName: 'deposit_address',
      type: 'string',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiNFTResponseHeader',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiMintNFTOnCCResponse.attributeTypeMap
  }
}

export class CoreapiMintNFTRequest {
  'assetManagerAddress'?: string
  'depositAddress'?: string
  'documentId'?: string
  'proofFields'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'assetManagerAddress',
      baseName: 'asset_manager_address',
      type: 'string',
    },
    {
      name: 'depositAddress',
      baseName: 'deposit_address',
      type: 'string',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'proofFields',
      baseName: 'proof_fields',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiMintNFTRequest.attributeTypeMap
  }
}

export class CoreapiMintNFTResponse {
  'depositAddress'?: string
  'documentId'?: string
  'header'?: CoreapiNFTResponseHeader
  'registryAddress'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'depositAddress',
      baseName: 'deposit_address',
      type: 'string',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiNFTResponseHeader',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiMintNFTResponse.attributeTypeMap
  }
}

export class CoreapiMonetaryValue {
  'chainId'?: string
  'id'?: string
  'value'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'chainId',
      baseName: 'chain_id',
      type: 'string',
    },
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'value',
      baseName: 'value',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiMonetaryValue.attributeTypeMap
  }
}

export class CoreapiNFT {
  'owner'?: string
  'registry'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'owner',
      baseName: 'owner',
      type: 'string',
    },
    {
      name: 'registry',
      baseName: 'registry',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiNFT.attributeTypeMap
  }
}

export class CoreapiNFTOwnerOnCCResponse {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   */
  'owner'?: string
  'registryAddress'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'owner',
      baseName: 'owner',
      type: 'string',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiNFTOwnerOnCCResponse.attributeTypeMap
  }
}

export class CoreapiNFTOwnerResponse {
  /**
   * 20 byte hex encoded ethereum address
   */
  'owner'?: string
  'registryAddress'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'owner',
      baseName: 'owner',
      type: 'string',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiNFTOwnerResponse.attributeTypeMap
  }
}

export class CoreapiNFTResponseHeader {
  'jobId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'jobId',
      baseName: 'job_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiNFTResponseHeader.attributeTypeMap
  }
}

export class CoreapiProofResponseHeader {
  'documentId'?: string
  'state'?: string
  'versionId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'state',
      baseName: 'state',
      type: 'string',
    },
    {
      name: 'versionId',
      baseName: 'version_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiProofResponseHeader.attributeTypeMap
  }
}

export class CoreapiProofsRequest {
  'fields'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'fields',
      baseName: 'fields',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiProofsRequest.attributeTypeMap
  }
}

export class CoreapiProofsResponse {
  'fieldProofs'?: Array<DocumentsProof>
  'header'?: CoreapiProofResponseHeader

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'fieldProofs',
      baseName: 'field_proofs',
      type: 'Array<DocumentsProof>',
    },
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiProofResponseHeader',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiProofsResponse.attributeTypeMap
  }
}

export class CoreapiResponseHeader {
  'author'?: string
  'createdAt'?: string
  'documentId'?: string
  'fingerprint'?: string
  'jobId'?: string
  'nextVersionId'?: string
  'nfts'?: Array<CoreapiNFT>
  'previousVersionId'?: string
  'readAccess'?: Array<string>
  'status'?: string
  'versionId'?: string
  'writeAccess'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'author',
      baseName: 'author',
      type: 'string',
    },
    {
      name: 'createdAt',
      baseName: 'created_at',
      type: 'string',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'fingerprint',
      baseName: 'fingerprint',
      type: 'string',
    },
    {
      name: 'jobId',
      baseName: 'job_id',
      type: 'string',
    },
    {
      name: 'nextVersionId',
      baseName: 'next_version_id',
      type: 'string',
    },
    {
      name: 'nfts',
      baseName: 'nfts',
      type: 'Array<CoreapiNFT>',
    },
    {
      name: 'previousVersionId',
      baseName: 'previous_version_id',
      type: 'string',
    },
    {
      name: 'readAccess',
      baseName: 'read_access',
      type: 'Array<string>',
    },
    {
      name: 'status',
      baseName: 'status',
      type: 'string',
    },
    {
      name: 'versionId',
      baseName: 'version_id',
      type: 'string',
    },
    {
      name: 'writeAccess',
      baseName: 'write_access',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiResponseHeader.attributeTypeMap
  }
}

export class CoreapiSignRequest {
  'payload'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'payload',
      baseName: 'payload',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiSignRequest.attributeTypeMap
  }
}

export class CoreapiSignResponse {
  'payload'?: string
  'publicKey'?: string
  'signature'?: string
  'signerId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'payload',
      baseName: 'payload',
      type: 'string',
    },
    {
      name: 'publicKey',
      baseName: 'public_key',
      type: 'string',
    },
    {
      name: 'signature',
      baseName: 'signature',
      type: 'string',
    },
    {
      name: 'signerId',
      baseName: 'signer_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiSignResponse.attributeTypeMap
  }
}

export class CoreapiSignedValue {
  'identity'?: string
  'value'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'identity',
      baseName: 'identity',
      type: 'string',
    },
    {
      name: 'value',
      baseName: 'value',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiSignedValue.attributeTypeMap
  }
}

export class CoreapiTransferNFTOnCCRequest {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   */
  'to'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'to',
      baseName: 'to',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiTransferNFTOnCCRequest.attributeTypeMap
  }
}

export class CoreapiTransferNFTOnCCResponse {
  'header'?: CoreapiNFTResponseHeader
  'registryAddress'?: string
  /**
   * 32 byte hex encoded account id on centrifuge chain
   */
  'to'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiNFTResponseHeader',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'to',
      baseName: 'to',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiTransferNFTOnCCResponse.attributeTypeMap
  }
}

export class CoreapiTransferNFTRequest {
  /**
   * 20 byte hex encoded ethereum address
   */
  'to'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'to',
      baseName: 'to',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiTransferNFTRequest.attributeTypeMap
  }
}

export class CoreapiTransferNFTResponse {
  'header'?: CoreapiNFTResponseHeader
  'registryAddress'?: string
  /**
   * 20 byte hex encoded ethereum address
   */
  'to'?: string
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'header',
      baseName: 'header',
      type: 'CoreapiNFTResponseHeader',
    },
    {
      name: 'registryAddress',
      baseName: 'registry_address',
      type: 'string',
    },
    {
      name: 'to',
      baseName: 'to',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return CoreapiTransferNFTResponse.attributeTypeMap
  }
}

export class DocumentsProof {
  'hash'?: string
  'property'?: string
  'salt'?: string
  'sortedHashes'?: Array<string>
  'value'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'hash',
      baseName: 'hash',
      type: 'string',
    },
    {
      name: 'property',
      baseName: 'property',
      type: 'string',
    },
    {
      name: 'salt',
      baseName: 'salt',
      type: 'string',
    },
    {
      name: 'sortedHashes',
      baseName: 'sorted_hashes',
      type: 'Array<string>',
    },
    {
      name: 'value',
      baseName: 'value',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return DocumentsProof.attributeTypeMap
  }
}

export class GoceleryTask {
  /**
   * arguments passed to this task
   */
  'args'?: Array<any>
  /**
   * delay until ready to be run
   */
  'delay'?: string
  /**
   * error after task run
   */
  'error'?: string
  /**
   * result after the task run
   */
  'result'?: any
  /**
   * name of the runnerFuncs
   */
  'runnerFuncs'?: string
  /**
   * number of times task was run.
   */
  'tries'?: number

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'args',
      baseName: 'args',
      type: 'Array<any>',
    },
    {
      name: 'delay',
      baseName: 'delay',
      type: 'string',
    },
    {
      name: 'error',
      baseName: 'error',
      type: 'string',
    },
    {
      name: 'result',
      baseName: 'result',
      type: 'any',
    },
    {
      name: 'runnerFuncs',
      baseName: 'runnerFuncs',
      type: 'string',
    },
    {
      name: 'tries',
      baseName: 'tries',
      type: 'number',
    },
  ]

  static getAttributeTypeMap() {
    return GoceleryTask.attributeTypeMap
  }
}

export class HealthPong {
  'network'?: string
  'version'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'network',
      baseName: 'network',
      type: 'string',
    },
    {
      name: 'version',
      baseName: 'version',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return HealthPong.attributeTypeMap
  }
}

export class HttputilsHTTPError {
  'message'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'message',
      baseName: 'message',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return HttputilsHTTPError.attributeTypeMap
  }
}

export class NotificationDocumentMessage {
  /**
   * document received from
   */
  'from'?: string
  /**
   * document identifier
   */
  'id'?: string
  /**
   * document sent to
   */
  'to'?: string
  /**
   * version identifier
   */
  'versionId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'from',
      baseName: 'from',
      type: 'string',
    },
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'to',
      baseName: 'to',
      type: 'string',
    },
    {
      name: 'versionId',
      baseName: 'version_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return NotificationDocumentMessage.attributeTypeMap
  }
}

export class NotificationJobMessage {
  /**
   * description of the job
   */
  'desc'?: string
  /**
   * job finished at
   */
  'finishedAt'?: string
  /**
   * job identifier
   */
  'id'?: string
  /**
   * job owner
   */
  'owner'?: string
  /**
   * validity of the job
   */
  'validUntil'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'desc',
      baseName: 'desc',
      type: 'string',
    },
    {
      name: 'finishedAt',
      baseName: 'finished_at',
      type: 'string',
    },
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'owner',
      baseName: 'owner',
      type: 'string',
    },
    {
      name: 'validUntil',
      baseName: 'valid_until',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return NotificationJobMessage.attributeTypeMap
  }
}

export class NotificationMessage {
  /**
   * Document contains recently received document. Ensure event type is document
   */
  'document'?: NotificationDocumentMessage
  'eventType'?: NotificationMessage.EventTypeEnum
  /**
   * Job contains jobs specific details. Ensure event type is job
   */
  'job'?: NotificationJobMessage
  'recordedAt'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'document',
      baseName: 'document',
      type: 'NotificationDocumentMessage',
    },
    {
      name: 'eventType',
      baseName: 'event_type',
      type: 'NotificationMessage.EventTypeEnum',
    },
    {
      name: 'job',
      baseName: 'job',
      type: 'NotificationJobMessage',
    },
    {
      name: 'recordedAt',
      baseName: 'recorded_at',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return NotificationMessage.attributeTypeMap
  }
}

export namespace NotificationMessage {
  export enum EventTypeEnum {
    Job = <any>'job',
    Document = <any>'document',
  }
}
export class OraclePushAttributeToOracleRequest {
  /**
   * hex value of the Attribute key
   */
  'attributeKey'?: string
  /**
   * hex value of the Oracle address
   */
  'oracleAddress'?: string
  /**
   * hex value of the NFT token
   */
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributeKey',
      baseName: 'attribute_key',
      type: 'string',
    },
    {
      name: 'oracleAddress',
      baseName: 'oracle_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return OraclePushAttributeToOracleRequest.attributeTypeMap
  }
}

export class OraclePushToOracleResponse {
  /**
   * hex value of the Attribute key
   */
  'attributeKey'?: string
  'jobId'?: string
  /**
   * hex value of the Oracle address
   */
  'oracleAddress'?: string
  /**
   * hex value of the NFT token
   */
  'tokenId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributeKey',
      baseName: 'attribute_key',
      type: 'string',
    },
    {
      name: 'jobId',
      baseName: 'job_id',
      type: 'string',
    },
    {
      name: 'oracleAddress',
      baseName: 'oracle_address',
      type: 'string',
    },
    {
      name: 'tokenId',
      baseName: 'token_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return OraclePushToOracleResponse.attributeTypeMap
  }
}

export class PendingAddTransitionRules {
  'attributeRules'?: Array<PendingAttributeRule>
  'computeFieldsRules'?: Array<PendingComputeFieldsRule>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributeRules',
      baseName: 'attribute_rules',
      type: 'Array<PendingAttributeRule>',
    },
    {
      name: 'computeFieldsRules',
      baseName: 'compute_fields_rules',
      type: 'Array<PendingComputeFieldsRule>',
    },
  ]

  static getAttributeTypeMap() {
    return PendingAddTransitionRules.attributeTypeMap
  }
}

export class PendingAttributeRule {
  /**
   * attribute key label
   */
  'keyLabel'?: string
  /**
   * roleID is 32 byte role ID in hex. RoleID should already be part of the document.
   */
  'roleId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'keyLabel',
      baseName: 'key_label',
      type: 'string',
    },
    {
      name: 'roleId',
      baseName: 'role_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return PendingAttributeRule.attributeTypeMap
  }
}

export class PendingComputeFieldsRule {
  /**
   * AttributeLabels that are passed to the WASM for execution
   */
  'attributeLabels'?: Array<string>
  /**
   * TargetAttributeLabel is the label of the attribute which holds the result from the executed WASM. This attribute is automatically added and updated everytime document is updated.
   */
  'targetAttributeLabel'?: string
  'wasm'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributeLabels',
      baseName: 'attribute_labels',
      type: 'Array<string>',
    },
    {
      name: 'targetAttributeLabel',
      baseName: 'target_attribute_label',
      type: 'string',
    },
    {
      name: 'wasm',
      baseName: 'wasm',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return PendingComputeFieldsRule.attributeTypeMap
  }
}

export class V2AddRole {
  'collaborators'?: Array<string>
  /**
   * Key is either hex encoded 32 byte ID or string label. String label is used as a preimage to sha256 for 32 byte hash.
   */
  'key'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'collaborators',
      baseName: 'collaborators',
      type: 'Array<string>',
    },
    {
      name: 'key',
      baseName: 'key',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return V2AddRole.attributeTypeMap
  }
}

export class V2CloneDocumentRequest {
  'scheme'?: V2CloneDocumentRequest.SchemeEnum

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'scheme',
      baseName: 'scheme',
      type: 'V2CloneDocumentRequest.SchemeEnum',
    },
  ]

  static getAttributeTypeMap() {
    return V2CloneDocumentRequest.attributeTypeMap
  }
}

export namespace V2CloneDocumentRequest {
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
export class V2CreateDocumentRequest {
  'attributes'?: CoreapiAttributeMapRequest
  'data'?: any
  /**
   * if provided, creates the next version of the document.
   */
  'documentId'?: string
  'readAccess'?: Array<string>
  'scheme'?: V2CreateDocumentRequest.SchemeEnum
  'writeAccess'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributes',
      baseName: 'attributes',
      type: 'CoreapiAttributeMapRequest',
    },
    {
      name: 'data',
      baseName: 'data',
      type: 'any',
    },
    {
      name: 'documentId',
      baseName: 'document_id',
      type: 'string',
    },
    {
      name: 'readAccess',
      baseName: 'read_access',
      type: 'Array<string>',
    },
    {
      name: 'scheme',
      baseName: 'scheme',
      type: 'V2CreateDocumentRequest.SchemeEnum',
    },
    {
      name: 'writeAccess',
      baseName: 'write_access',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return V2CreateDocumentRequest.attributeTypeMap
  }
}

export namespace V2CreateDocumentRequest {
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
export class V2GenerateAccountResponse {
  'did'?: string
  'jobId'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'did',
      baseName: 'did',
      type: 'string',
    },
    {
      name: 'jobId',
      baseName: 'job_id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return V2GenerateAccountResponse.attributeTypeMap
  }
}

export class V2Job {
  /**
   * Job Identifier
   */
  'jobID'?: string
  /**
   * description of the Job
   */
  'desc'?: string
  /**
   * job status
   */
  'finished'?: boolean
  /**
   * Job finished at. If empty, job is not complete yet
   */
  'finishedAt'?: string
  /**
   * overrides for the Job
   */
  'overrides'?: any
  /**
   * name of the Runner
   */
  'runner'?: string
  /**
   * list of tasks ran under this Job
   */
  'tasks'?: Array<GoceleryTask>
  /**
   * validity of the job
   */
  'validUntil'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'jobID',
      baseName: 'JobID',
      type: 'string',
    },
    {
      name: 'desc',
      baseName: 'desc',
      type: 'string',
    },
    {
      name: 'finished',
      baseName: 'finished',
      type: 'boolean',
    },
    {
      name: 'finishedAt',
      baseName: 'finished_at',
      type: 'string',
    },
    {
      name: 'overrides',
      baseName: 'overrides',
      type: 'any',
    },
    {
      name: 'runner',
      baseName: 'runner',
      type: 'string',
    },
    {
      name: 'tasks',
      baseName: 'tasks',
      type: 'Array<GoceleryTask>',
    },
    {
      name: 'validUntil',
      baseName: 'valid_until',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return V2Job.attributeTypeMap
  }
}

export class V2RemoveCollaboratorsRequest {
  'collaborators'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'collaborators',
      baseName: 'collaborators',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return V2RemoveCollaboratorsRequest.attributeTypeMap
  }
}

export class V2Role {
  'collaborators'?: Array<string>
  'id'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'collaborators',
      baseName: 'collaborators',
      type: 'Array<string>',
    },
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return V2Role.attributeTypeMap
  }
}

export class V2SignedAttributeRequest {
  'label'?: string
  'payload'?: string
  'type'?: V2SignedAttributeRequest.TypeEnum

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'label',
      baseName: 'label',
      type: 'string',
    },
    {
      name: 'payload',
      baseName: 'payload',
      type: 'string',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'V2SignedAttributeRequest.TypeEnum',
    },
  ]

  static getAttributeTypeMap() {
    return V2SignedAttributeRequest.attributeTypeMap
  }
}

export namespace V2SignedAttributeRequest {
  export enum TypeEnum {
    Integer = <any>'integer',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
  }
}
export class V2TransitionRule {
  'action'?: string
  'attributeLabels'?: Array<string>
  'field'?: string
  'roles'?: Array<string>
  'ruleId'?: string
  'targetAttributeLabel'?: string
  'wasm'?: string

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'action',
      baseName: 'action',
      type: 'string',
    },
    {
      name: 'attributeLabels',
      baseName: 'attribute_labels',
      type: 'Array<string>',
    },
    {
      name: 'field',
      baseName: 'field',
      type: 'string',
    },
    {
      name: 'roles',
      baseName: 'roles',
      type: 'Array<string>',
    },
    {
      name: 'ruleId',
      baseName: 'rule_id',
      type: 'string',
    },
    {
      name: 'targetAttributeLabel',
      baseName: 'target_attribute_label',
      type: 'string',
    },
    {
      name: 'wasm',
      baseName: 'wasm',
      type: 'string',
    },
  ]

  static getAttributeTypeMap() {
    return V2TransitionRule.attributeTypeMap
  }
}

export class V2TransitionRules {
  'rules'?: Array<V2TransitionRule>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'rules',
      baseName: 'rules',
      type: 'Array<V2TransitionRule>',
    },
  ]

  static getAttributeTypeMap() {
    return V2TransitionRules.attributeTypeMap
  }
}

export class V2UpdateDocumentRequest {
  'attributes'?: CoreapiAttributeMapRequest
  'data'?: any
  'readAccess'?: Array<string>
  'scheme'?: V2UpdateDocumentRequest.SchemeEnum
  'writeAccess'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'attributes',
      baseName: 'attributes',
      type: 'CoreapiAttributeMapRequest',
    },
    {
      name: 'data',
      baseName: 'data',
      type: 'any',
    },
    {
      name: 'readAccess',
      baseName: 'read_access',
      type: 'Array<string>',
    },
    {
      name: 'scheme',
      baseName: 'scheme',
      type: 'V2UpdateDocumentRequest.SchemeEnum',
    },
    {
      name: 'writeAccess',
      baseName: 'write_access',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return V2UpdateDocumentRequest.attributeTypeMap
  }
}

export namespace V2UpdateDocumentRequest {
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
export class V2UpdateRole {
  'collaborators'?: Array<string>

  static discriminator: string | undefined = undefined

  static attributeTypeMap: Array<{ name: string; baseName: string; type: string }> = [
    {
      name: 'collaborators',
      baseName: 'collaborators',
      type: 'Array<string>',
    },
  ]

  static getAttributeTypeMap() {
    return V2UpdateRole.attributeTypeMap
  }
}

let enumsMap: { [index: string]: any } = {
  'CoreapiAttributeRequest.TypeEnum': CoreapiAttributeRequest.TypeEnum,
  'CoreapiAttributeResponse.TypeEnum': CoreapiAttributeResponse.TypeEnum,
  'CoreapiDocumentResponse.SchemeEnum': CoreapiDocumentResponse.SchemeEnum,
  'NotificationMessage.EventTypeEnum': NotificationMessage.EventTypeEnum,
  'V2CloneDocumentRequest.SchemeEnum': V2CloneDocumentRequest.SchemeEnum,
  'V2CreateDocumentRequest.SchemeEnum': V2CreateDocumentRequest.SchemeEnum,
  'V2SignedAttributeRequest.TypeEnum': V2SignedAttributeRequest.TypeEnum,
  'V2UpdateDocumentRequest.SchemeEnum': V2UpdateDocumentRequest.SchemeEnum,
}

let typeMap: { [index: string]: any } = {
  ConfigCentChainAccount: ConfigCentChainAccount,
  CoreapiAccount: CoreapiAccount,
  CoreapiAccounts: CoreapiAccounts,
  CoreapiAttributeMapRequest: CoreapiAttributeMapRequest,
  CoreapiAttributeMapResponse: CoreapiAttributeMapResponse,
  CoreapiAttributeRequest: CoreapiAttributeRequest,
  CoreapiAttributeResponse: CoreapiAttributeResponse,
  CoreapiDocumentResponse: CoreapiDocumentResponse,
  CoreapiEthAccount: CoreapiEthAccount,
  CoreapiGenerateAccountPayload: CoreapiGenerateAccountPayload,
  CoreapiKeyPair: CoreapiKeyPair,
  CoreapiMintNFTOnCCRequest: CoreapiMintNFTOnCCRequest,
  CoreapiMintNFTOnCCResponse: CoreapiMintNFTOnCCResponse,
  CoreapiMintNFTRequest: CoreapiMintNFTRequest,
  CoreapiMintNFTResponse: CoreapiMintNFTResponse,
  CoreapiMonetaryValue: CoreapiMonetaryValue,
  CoreapiNFT: CoreapiNFT,
  CoreapiNFTOwnerOnCCResponse: CoreapiNFTOwnerOnCCResponse,
  CoreapiNFTOwnerResponse: CoreapiNFTOwnerResponse,
  CoreapiNFTResponseHeader: CoreapiNFTResponseHeader,
  CoreapiProofResponseHeader: CoreapiProofResponseHeader,
  CoreapiProofsRequest: CoreapiProofsRequest,
  CoreapiProofsResponse: CoreapiProofsResponse,
  CoreapiResponseHeader: CoreapiResponseHeader,
  CoreapiSignRequest: CoreapiSignRequest,
  CoreapiSignResponse: CoreapiSignResponse,
  CoreapiSignedValue: CoreapiSignedValue,
  CoreapiTransferNFTOnCCRequest: CoreapiTransferNFTOnCCRequest,
  CoreapiTransferNFTOnCCResponse: CoreapiTransferNFTOnCCResponse,
  CoreapiTransferNFTRequest: CoreapiTransferNFTRequest,
  CoreapiTransferNFTResponse: CoreapiTransferNFTResponse,
  DocumentsProof: DocumentsProof,
  GoceleryTask: GoceleryTask,
  HealthPong: HealthPong,
  HttputilsHTTPError: HttputilsHTTPError,
  NotificationDocumentMessage: NotificationDocumentMessage,
  NotificationJobMessage: NotificationJobMessage,
  NotificationMessage: NotificationMessage,
  OraclePushAttributeToOracleRequest: OraclePushAttributeToOracleRequest,
  OraclePushToOracleResponse: OraclePushToOracleResponse,
  PendingAddTransitionRules: PendingAddTransitionRules,
  PendingAttributeRule: PendingAttributeRule,
  PendingComputeFieldsRule: PendingComputeFieldsRule,
  V2AddRole: V2AddRole,
  V2CloneDocumentRequest: V2CloneDocumentRequest,
  V2CreateDocumentRequest: V2CreateDocumentRequest,
  V2GenerateAccountResponse: V2GenerateAccountResponse,
  V2Job: V2Job,
  V2RemoveCollaboratorsRequest: V2RemoveCollaboratorsRequest,
  V2Role: V2Role,
  V2SignedAttributeRequest: V2SignedAttributeRequest,
  V2TransitionRule: V2TransitionRule,
  V2TransitionRules: V2TransitionRules,
  V2UpdateDocumentRequest: V2UpdateDocumentRequest,
  V2UpdateRole: V2UpdateRole,
}

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void
}

export class HttpBasicAuth implements Authentication {
  public username: string = ''
  public password: string = ''

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    }
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = ''

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == 'query') {
      ;(<any>requestOptions.qs)[this.paramName] = this.apiKey
    } else if (this.location == 'header' && requestOptions && requestOptions.headers) {
      requestOptions.headers[this.paramName] = this.apiKey
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = ''

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers['Authorization'] = 'Bearer ' + this.accessToken
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = ''
  public password: string = ''

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum AccountsApiApiKeys {}

export class AccountsApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: AccountsApiApiKeys, value: string) {
    ;(this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value
  }
  /**
   * Signs and returns the signature of the Payload.
   * @summary Signs and returns the signature of the Payload.
   * @param accountId Account ID
   * @param body Sign request
   * @param {*} [options] Override http request options.
   */
  public accountSign(
    accountId: string,
    body: CoreapiSignRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiSignResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/accounts/{account_id}/sign'.replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling accountSign.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling accountSign.')
    }

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiSignRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiSignResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiSignResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Generates a new account with defaults.
   * @summary Generates a new account with defaults.
   * @param body Generate Account Payload
   * @param {*} [options] Override http request options.
   */
  public generateAccountV2(
    body: CoreapiGenerateAccountPayload,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2GenerateAccountResponse }> {
    const localVarPath = this.basePath + '/v2/accounts/generate'
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling generateAccountV2.')
    }

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiGenerateAccountPayload'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2GenerateAccountResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2GenerateAccountResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the account associated with accountID.
   * @summary Returns the account associated with accountID.
   * @param accountId Account ID
   * @param {*} [options] Override http request options.
   */
  public getAccount(
    accountId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiAccount }> {
    const localVarPath =
      this.basePath +
      '/v2/accounts/{account_id}'.replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling getAccount.')
    }

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiAccount }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiAccount')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns all the accounts in the node.
   * @summary Returns all the accounts in the node.
   * @param {*} [options] Override http request options.
   */
  public getAccounts(options: any = {}): Promise<{ response: http.ClientResponse; body: CoreapiAccounts }> {
    const localVarPath = this.basePath + '/v2/accounts'
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiAccounts }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiAccounts')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
export enum DocumentsApiApiKeys {}

export class DocumentsApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: DocumentsApiApiKeys, value: string) {
    ;(this.authentications as any)[DocumentsApiApiKeys[key]].apiKey = value
  }
  /**
   * Add attributes to pending document.
   * @summary Add attributes to pending document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Attributes
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public addAttributes(
    authorization: string,
    body: CoreapiAttributeMapRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/attributes'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addAttributes.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling addAttributes.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling addAttributes.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiAttributeMapRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Adds a new role to the document.
   * @summary Adds a new role to the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param body Add Role Request
   * @param {*} [options] Override http request options.
   */
  public addRole(
    authorization: string,
    documentId: string,
    body: V2AddRole,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2Role }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/roles'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRole.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling addRole.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling addRole.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2AddRole'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2Role }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2Role')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Signs the given payload and add it the pending document.
   * @summary Signs the given payload and add it the pending document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Signed Attribute request
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public addSignedAttribute(
    authorization: string,
    body: V2SignedAttributeRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/signed_attribute'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addSignedAttribute.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling addSignedAttribute.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling addSignedAttribute.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2SignedAttributeRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Adds a new transition rules to the document.
   * @summary Adds a transition new rules to the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param body Add Transition rules Request
   * @param {*} [options] Override http request options.
   */
  public addTransitionRule(
    authorization: string,
    documentId: string,
    body: PendingAddTransitionRules,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2TransitionRules }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/transition_rules'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addTransitionRule.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling addTransitionRule.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling addTransitionRule.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'PendingAddTransitionRules'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2TransitionRules }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2TransitionRules')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Creates a new cloned document from an existing Template document.
   * @summary Creates a new cloned document from an existing Template document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Document Clone request
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public cloneDocumentV2(
    authorization: string,
    body: V2CloneDocumentRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/clone'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling cloneDocumentV2.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling cloneDocumentV2.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling cloneDocumentV2.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2CloneDocumentRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Commits a pending document.
   * @summary Commits a pending document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public commitDocumentV2(
    authorization: string,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/commit'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling commitDocumentV2.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling commitDocumentV2.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Creates a new document.
   * @summary Creates a new document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Document Create request
   * @param {*} [options] Override http request options.
   */
  public createDocumentV2(
    authorization: string,
    body: V2CreateDocumentRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath = this.basePath + '/v2/documents'
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createDocumentV2.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createDocumentV2.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2CreateDocumentRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Deletes attribute on a pending document.
   * @summary Deletes attribute on a pending document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param attributeKey Hex encoded attribute key
   * @param {*} [options] Override http request options.
   */
  public deleteAttribute(
    authorization: string,
    documentId: string,
    attributeKey: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/attributes/{attribute_key}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'attribute_key' + '}', encodeURIComponent(String(attributeKey)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteAttribute.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling deleteAttribute.')
    }

    // verify required parameter 'attributeKey' is not null or undefined
    if (attributeKey === null || attributeKey === undefined) {
      throw new Error('Required parameter attributeKey was null or undefined when calling deleteAttribute.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Deletes the transition rule associated with ruleID from the document.
   * @summary Deletes the transition rule associated with ruleID from the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param ruleId Transition rule ID
   * @param {*} [options] Override http request options.
   */
  public deleteTransitionRule(
    authorization: string,
    documentId: string,
    ruleId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/transition_rules/{rule_id}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'rule_id' + '}', encodeURIComponent(String(ruleId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteTransitionRule.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling deleteTransitionRule.')
    }

    // verify required parameter 'ruleId' is not null or undefined
    if (ruleId === null || ruleId === undefined) {
      throw new Error('Required parameter ruleId was null or undefined when calling deleteTransitionRule.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Generates proofs for the fields from latest version of the document.
   * @summary Generates proofs for the fields from latest version of the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param body Document proof request
   * @param {*} [options] Override http request options.
   */
  public generateDocumentProofs(
    authorization: string,
    documentId: string,
    body: CoreapiProofsRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiProofsResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/proofs'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling generateDocumentProofs.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling generateDocumentProofs.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling generateDocumentProofs.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiProofsRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiProofsResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiProofsResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Generates proofs for the fields from a specific document version.
   * @summary Generates proofs for the fields from a specific document version.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param versionId Document Version Identifier
   * @param body Document proof request
   * @param {*} [options] Override http request options.
   */
  public generateDocumentVersionProofs(
    authorization: string,
    documentId: string,
    versionId: string,
    body: CoreapiProofsRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiProofsResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/versions/{version_id}/proofs'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'version_id' + '}', encodeURIComponent(String(versionId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error(
        'Required parameter authorization was null or undefined when calling generateDocumentVersionProofs.'
      )
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling generateDocumentVersionProofs.')
    }

    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new Error('Required parameter versionId was null or undefined when calling generateDocumentVersionProofs.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling generateDocumentVersionProofs.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiProofsRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiProofsResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiProofsResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the latest committed document associated with docID.
   * @summary Returns the latest committed document associated with docID.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public getCommittedDocument(
    authorization: string,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/committed'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getCommittedDocument.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getCommittedDocument.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the specific version of the document.
   * @summary Returns the specific version of the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param versionId Document Version Identifier
   * @param {*} [options] Override http request options.
   */
  public getDocumentVersionV2(
    authorization: string,
    documentId: string,
    versionId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/versions/{version_id}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'version_id' + '}', encodeURIComponent(String(versionId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getDocumentVersionV2.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getDocumentVersionV2.')
    }

    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new Error('Required parameter versionId was null or undefined when calling getDocumentVersionV2.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the entity relationships.
   * @summary Returns the entity relationships.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public getEntityRelationships(
    authorization: string,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<CoreapiDocumentResponse> }> {
    const localVarPath =
      this.basePath +
      '/v2/entities/{document_id}/relationships'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getEntityRelationships.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getEntityRelationships.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<CoreapiDocumentResponse> }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<CoreapiDocumentResponse>')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the latest version of the Entity through relationship ID.
   * @summary Returns the latest version of the Entity through relationship ID.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Entity Relationship Document Identifier
   * @param {*} [options] Override http request options.
   */
  public getEntityThroughRelationshipId(
    authorization: string,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/relationships/{document_id}/entity'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error(
        'Required parameter authorization was null or undefined when calling getEntityThroughRelationshipId.'
      )
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error(
        'Required parameter documentId was null or undefined when calling getEntityThroughRelationshipId.'
      )
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the pending document associated with docID.
   * @summary Returns the pending document associated with docID.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public getPendingDocument(
    authorization: string,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/pending'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getPendingDocument.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getPendingDocument.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the role associated with the role ID in the document.
   * @summary Returns the role associated with the role ID in the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param roleId Role ID
   * @param {*} [options] Override http request options.
   */
  public getRole(
    authorization: string,
    documentId: string,
    roleId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2Role }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/roles/{role_id}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'role_id' + '}', encodeURIComponent(String(roleId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getRole.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getRole.')
    }

    // verify required parameter 'roleId' is not null or undefined
    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling getRole.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2Role }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2Role')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the rule associated with the ruleID in the document.
   * @summary Returns the rule associated with the ruleID in the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param ruleId Transition rule ID
   * @param {*} [options] Override http request options.
   */
  public getTransitionRule(
    authorization: string,
    documentId: string,
    ruleId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2TransitionRule }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/transition_rules/{rule_id}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'rule_id' + '}', encodeURIComponent(String(ruleId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getTransitionRule.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling getTransitionRule.')
    }

    // verify required parameter 'ruleId' is not null or undefined
    if (ruleId === null || ruleId === undefined) {
      throw new Error('Required parameter ruleId was null or undefined when calling getTransitionRule.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2TransitionRule }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2TransitionRule')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Removes the collaborators from the document.
   * @summary Removes the collaborators from the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Remove Collaborators request
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public removeCollaborators(
    authorization: string,
    body: V2RemoveCollaboratorsRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/collaborators'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeCollaborators.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling removeCollaborators.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling removeCollaborators.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'DELETE',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2RemoveCollaboratorsRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Updates a pending document.
   * @summary Updates a pending document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Document Update request
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public updateDocumentV2(
    authorization: string,
    body: V2UpdateDocumentRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}'.replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling updateDocumentV2.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateDocumentV2.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling updateDocumentV2.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2UpdateDocumentRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiDocumentResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiDocumentResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Updates an existing role on the document.
   * @summary Updates an existing role on the document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param documentId Document Identifier
   * @param roleId Role ID
   * @param body Update Role Request
   * @param {*} [options] Override http request options.
   */
  public updateRole(
    authorization: string,
    documentId: string,
    roleId: string,
    body: V2UpdateRole,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2Role }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/roles/{role_id}'
        .replace('{' + 'document_id' + '}', encodeURIComponent(String(documentId)))
        .replace('{' + 'role_id' + '}', encodeURIComponent(String(roleId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling updateRole.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling updateRole.')
    }

    // verify required parameter 'roleId' is not null or undefined
    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling updateRole.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateRole.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PATCH',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'V2UpdateRole'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2Role }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2Role')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
export enum HealthApiApiKeys {}

export class HealthApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: HealthApiApiKeys, value: string) {
    ;(this.authentications as any)[HealthApiApiKeys[key]].apiKey = value
  }
  /**
   * returns node version and network
   * @summary Health check for Node
   * @param {*} [options] Override http request options.
   */
  public ping(options: any = {}): Promise<{ response: http.ClientResponse; body: HealthPong }> {
    const localVarPath = this.basePath + '/ping'
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: HealthPong }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'HealthPong')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
export enum JobsApiApiKeys {}

export class JobsApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: JobsApiApiKeys, value: string) {
    ;(this.authentications as any)[JobsApiApiKeys[key]].apiKey = value
  }
  /**
   * Returns the details of a given Job.
   * @summary Returns the details of a given Job.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param jobId Hex encoded Job ID
   * @param {*} [options] Override http request options.
   */
  public getJob(
    authorization: string,
    jobId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: V2Job }> {
    const localVarPath =
      this.basePath + '/v2/jobs/{job_id}'.replace('{' + 'job_id' + '}', encodeURIComponent(String(jobId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getJob.')
    }

    // verify required parameter 'jobId' is not null or undefined
    if (jobId === null || jobId === undefined) {
      throw new Error('Required parameter jobId was null or undefined when calling getJob.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: V2Job }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'V2Job')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
export enum NFTsApiApiKeys {}

export class NFTsApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: NFTsApiApiKeys, value: string) {
    ;(this.authentications as any)[NFTsApiApiKeys[key]].apiKey = value
  }
  /**
   * Mints an NFT against a document.
   * @summary Mints an NFT against a document.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param registryAddress NFT registry address in hex
   * @param body Mint NFT request
   * @param {*} [options] Override http request options.
   */
  public mintNft(
    authorization: string,
    registryAddress: string,
    body: CoreapiMintNFTRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiMintNFTResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/nfts/registries/{registry_address}/mint'.replace(
        '{' + 'registry_address' + '}',
        encodeURIComponent(String(registryAddress))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling mintNft.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling mintNft.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling mintNft.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiMintNFTRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiMintNFTResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiMintNFTResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Mints an NFT against a document on centrifuge chain.
   * @summary Mints an NFT against a document on centrifuge chain.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param registryAddress NFT registry address in hex
   * @param body Mint NFT on CC request
   * @param {*} [options] Override http request options.
   */
  public mintNftCc(
    authorization: string,
    registryAddress: string,
    body: CoreapiMintNFTOnCCRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiMintNFTOnCCResponse }> {
    const localVarPath =
      this.basePath +
      '/beta/nfts/registries/{registry_address}/mint'.replace(
        '{' + 'registry_address' + '}',
        encodeURIComponent(String(registryAddress))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling mintNftCc.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling mintNftCc.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling mintNftCc.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiMintNFTOnCCRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiMintNFTOnCCResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiMintNFTOnCCResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the Owner of the given NFT.
   * @summary Returns the Owner of the given NFT.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param tokenId NFT token ID in hex
   * @param registryAddress Registry address in hex
   * @param {*} [options] Override http request options.
   */
  public ownerOfNft(
    authorization: string,
    tokenId: string,
    registryAddress: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiNFTOwnerResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/nfts/registries/{registry_address}/tokens/{token_id}/owner'
        .replace('{' + 'token_id' + '}', encodeURIComponent(String(tokenId)))
        .replace('{' + 'registry_address' + '}', encodeURIComponent(String(registryAddress)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling ownerOfNft.')
    }

    // verify required parameter 'tokenId' is not null or undefined
    if (tokenId === null || tokenId === undefined) {
      throw new Error('Required parameter tokenId was null or undefined when calling ownerOfNft.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling ownerOfNft.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiNFTOwnerResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiNFTOwnerResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Returns the Owner of the given NFT on centrifuge chain.
   * @summary Returns the Owner of the given NFT on centrifuge chain.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param tokenId NFT token ID in hex
   * @param registryAddress Registry address in hex
   * @param {*} [options] Override http request options.
   */
  public ownerOfNftCc(
    authorization: string,
    tokenId: string,
    registryAddress: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiNFTOwnerOnCCResponse }> {
    const localVarPath =
      this.basePath +
      '/beta/nfts/registries/{registry_address}/tokens/{token_id}/owner'
        .replace('{' + 'token_id' + '}', encodeURIComponent(String(tokenId)))
        .replace('{' + 'registry_address' + '}', encodeURIComponent(String(registryAddress)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling ownerOfNftCc.')
    }

    // verify required parameter 'tokenId' is not null or undefined
    if (tokenId === null || tokenId === undefined) {
      throw new Error('Required parameter tokenId was null or undefined when calling ownerOfNftCc.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling ownerOfNftCc.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiNFTOwnerOnCCResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiNFTOwnerOnCCResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Pushes a given attribute value to oracle.
   * @summary Pushes a given attribute value to oracle.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param body Push Attribute to Oracle Request
   * @param documentId Document Identifier
   * @param {*} [options] Override http request options.
   */
  public pushAttributeOracle(
    authorization: string,
    body: OraclePushAttributeToOracleRequest,
    documentId: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: OraclePushToOracleResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/documents/{document_id}/push_to_oracle'.replace(
        '{' + 'document_id' + '}',
        encodeURIComponent(String(documentId))
      )
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling pushAttributeOracle.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling pushAttributeOracle.')
    }

    // verify required parameter 'documentId' is not null or undefined
    if (documentId === null || documentId === undefined) {
      throw new Error('Required parameter documentId was null or undefined when calling pushAttributeOracle.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'OraclePushAttributeToOracleRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: OraclePushToOracleResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'OraclePushToOracleResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Transfers given NFT to provide address.
   * @summary Transfers given NFT to provide address.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param registryAddress NFT registry address in hex
   * @param tokenId NFT token ID in hex
   * @param body Transfer NFT request
   * @param {*} [options] Override http request options.
   */
  public transferNft(
    authorization: string,
    registryAddress: string,
    tokenId: string,
    body: CoreapiTransferNFTRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiTransferNFTResponse }> {
    const localVarPath =
      this.basePath +
      '/v2/nfts/registries/{registry_address}/tokens/{token_id}/transfer'
        .replace('{' + 'registry_address' + '}', encodeURIComponent(String(registryAddress)))
        .replace('{' + 'token_id' + '}', encodeURIComponent(String(tokenId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling transferNft.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling transferNft.')
    }

    // verify required parameter 'tokenId' is not null or undefined
    if (tokenId === null || tokenId === undefined) {
      throw new Error('Required parameter tokenId was null or undefined when calling transferNft.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling transferNft.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiTransferNFTRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiTransferNFTResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiTransferNFTResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
  /**
   * Transfers given NFT to provide address on centrifuge chain.
   * @summary Transfers given NFT to provide address on centrifuge chain.
   * @param authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param registryAddress NFT registry address in hex
   * @param tokenId NFT token ID in hex
   * @param body Transfer NFT request
   * @param {*} [options] Override http request options.
   */
  public transferNftCc(
    authorization: string,
    registryAddress: string,
    tokenId: string,
    body: CoreapiTransferNFTOnCCRequest,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: CoreapiTransferNFTOnCCResponse }> {
    const localVarPath =
      this.basePath +
      '/beta/nfts/registries/{registry_address}/tokens/{token_id}/transfer'
        .replace('{' + 'registry_address' + '}', encodeURIComponent(String(registryAddress)))
        .replace('{' + 'token_id' + '}', encodeURIComponent(String(tokenId)))
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    // verify required parameter 'authorization' is not null or undefined
    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling transferNftCc.')
    }

    // verify required parameter 'registryAddress' is not null or undefined
    if (registryAddress === null || registryAddress === undefined) {
      throw new Error('Required parameter registryAddress was null or undefined when calling transferNftCc.')
    }

    // verify required parameter 'tokenId' is not null or undefined
    if (tokenId === null || tokenId === undefined) {
      throw new Error('Required parameter tokenId was null or undefined when calling transferNftCc.')
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling transferNftCc.')
    }

    localVarHeaderParams['authorization'] = ObjectSerializer.serialize(authorization, 'string')
    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'CoreapiTransferNFTOnCCRequest'),
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CoreapiTransferNFTOnCCResponse }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'CoreapiTransferNFTOnCCResponse')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
export enum WebhookApiApiKeys {}

export class WebhookApi {
  protected _basePath = defaultBasePath
  protected defaultHeaders: any = {}
  protected _useQuerystring: boolean = false

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string)
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value
  }

  set basePath(basePath: string) {
    this._basePath = basePath
  }

  get basePath() {
    return this._basePath
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth
  }

  public setApiKey(key: WebhookApiApiKeys, value: string) {
    ;(this.authentications as any)[WebhookApiApiKeys[key]].apiKey = value
  }
  /**
   * Webhook is a place holder to describe webhook response in swagger.
   * @summary Webhook is a place holder to describe webhook response in swagger.
   * @param {*} [options] Override http request options.
   */
  public webhook(options: any = {}): Promise<{ response: http.ClientResponse; body: NotificationMessage }> {
    const localVarPath = this.basePath + '/webhook'
    let localVarQueryParameters: any = {}
    let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders)
    let localVarFormParams: any = {}

    ;(<any>Object).assign(localVarHeaderParams, options.headers)

    let localVarUseFormData = false

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    }

    this.authentications.default.applyToRequest(localVarRequestOptions)

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        ;(<any>localVarRequestOptions).formData = localVarFormParams
      } else {
        localVarRequestOptions.form = localVarFormParams
      }
    }
    return new Promise<{ response: http.ClientResponse; body: NotificationMessage }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error)
        } else {
          body = ObjectSerializer.deserialize(body, 'NotificationMessage')
          if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body })
          } else {
            reject({ response: response, body: body })
          }
        }
      })
    })
  }
}
