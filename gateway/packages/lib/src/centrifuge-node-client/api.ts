/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Centrifuge OS Node API
 * Centrifuge OS Node API
 *
 * OpenAPI spec version: 2.0.0
 * Contact: hello@centrifuge.io
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import isomorphicFetch from 'isomorphic-fetch'
import * as url from 'url'
import { Configuration } from './configuration'

const BASE_PATH = 'http://34.89.173.240:8082/'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface ConfigCentChainAccount
 */
export interface ConfigCentChainAccount {
  /**
   *
   * @type {string}
   * @memberof ConfigCentChainAccount
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ConfigCentChainAccount
   */
  secret?: string
  /**
   *
   * @type {string}
   * @memberof ConfigCentChainAccount
   */
  ss58Address?: string
}
/**
 *
 * @export
 * @interface CoreapiAccount
 */
export interface CoreapiAccount {
  /**
   *
   * @type {ConfigCentChainAccount}
   * @memberof CoreapiAccount
   */
  centrifugeChainAccount?: ConfigCentChainAccount
  /**
   *
   * @type {CoreapiEthAccount}
   * @memberof CoreapiAccount
   */
  ethAccount?: CoreapiEthAccount
  /**
   *
   * @type {string}
   * @memberof CoreapiAccount
   */
  ethDefaultAccountName?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiAccount
   */
  identityId?: string
  /**
   *
   * @type {CoreapiKeyPair}
   * @memberof CoreapiAccount
   */
  p2pKeyPair?: CoreapiKeyPair
  /**
   *
   * @type {string}
   * @memberof CoreapiAccount
   */
  receiveEventNotificationEndpoint?: string
  /**
   *
   * @type {CoreapiKeyPair}
   * @memberof CoreapiAccount
   */
  signingKeyPair?: CoreapiKeyPair
}
/**
 *
 * @export
 * @interface CoreapiAccounts
 */
export interface CoreapiAccounts {
  /**
   *
   * @type {Array<CoreapiAccount>}
   * @memberof CoreapiAccounts
   */
  data?: Array<CoreapiAccount>
}
/**
 *
 * @export
 * @interface CoreapiAttributeMapRequest
 */
export interface CoreapiAttributeMapRequest {
  [key: string]: CoreapiAttributeRequest
}
/**
 *
 * @export
 * @interface CoreapiAttributeMapResponse
 */
export interface CoreapiAttributeMapResponse {
  [key: string]: CoreapiAttributeResponse
}
/**
 *
 * @export
 * @interface CoreapiAttributeRequest
 */
export interface CoreapiAttributeRequest {
  /**
   *
   * @type {CoreapiMonetaryValue}
   * @memberof CoreapiAttributeRequest
   */
  monetaryValue?: CoreapiMonetaryValue
  /**
   *
   * @type {string}
   * @memberof CoreapiAttributeRequest
   */
  type?: CoreapiAttributeRequest.TypeEnum
  /**
   *
   * @type {string}
   * @memberof CoreapiAttributeRequest
   */
  value?: string
}

/**
 * @export
 * @namespace CoreapiAttributeRequest
 */
export namespace CoreapiAttributeRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Integer = <any>'integer',
    Decimal = <any>'decimal',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
    Monetary = <any>'monetary',
  }
}
/**
 *
 * @export
 * @interface CoreapiAttributeResponse
 */
export interface CoreapiAttributeResponse {
  /**
   *
   * @type {string}
   * @memberof CoreapiAttributeResponse
   */
  key?: string
  /**
   *
   * @type {CoreapiMonetaryValue}
   * @memberof CoreapiAttributeResponse
   */
  monetaryValue?: CoreapiMonetaryValue
  /**
   *
   * @type {CoreapiSignedValue}
   * @memberof CoreapiAttributeResponse
   */
  signedValue?: CoreapiSignedValue
  /**
   *
   * @type {string}
   * @memberof CoreapiAttributeResponse
   */
  type?: CoreapiAttributeResponse.TypeEnum
  /**
   *
   * @type {string}
   * @memberof CoreapiAttributeResponse
   */
  value?: string
}

/**
 * @export
 * @namespace CoreapiAttributeResponse
 */
export namespace CoreapiAttributeResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Integer = <any>'integer',
    Decimal = <any>'decimal',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
    Monetary = <any>'monetary',
  }
}
/**
 *
 * @export
 * @interface CoreapiDocumentResponse
 */
export interface CoreapiDocumentResponse {
  /**
   *
   * @type {CoreapiAttributeMapResponse}
   * @memberof CoreapiDocumentResponse
   */
  attributes?: CoreapiAttributeMapResponse
  /**
   *
   * @type {any}
   * @memberof CoreapiDocumentResponse
   */
  data?: any
  /**
   *
   * @type {CoreapiResponseHeader}
   * @memberof CoreapiDocumentResponse
   */
  header?: CoreapiResponseHeader
  /**
   *
   * @type {string}
   * @memberof CoreapiDocumentResponse
   */
  scheme?: CoreapiDocumentResponse.SchemeEnum
}

/**
 * @export
 * @namespace CoreapiDocumentResponse
 */
export namespace CoreapiDocumentResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
/**
 *
 * @export
 * @interface CoreapiEthAccount
 */
export interface CoreapiEthAccount {
  /**
   *
   * @type {string}
   * @memberof CoreapiEthAccount
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiEthAccount
   */
  key?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiEthAccount
   */
  password?: string
}
/**
 *
 * @export
 * @interface CoreapiGenerateAccountPayload
 */
export interface CoreapiGenerateAccountPayload {
  /**
   *
   * @type {ConfigCentChainAccount}
   * @memberof CoreapiGenerateAccountPayload
   */
  centrifugeChainAccount?: ConfigCentChainAccount
}
/**
 *
 * @export
 * @interface CoreapiKeyPair
 */
export interface CoreapiKeyPair {
  /**
   *
   * @type {string}
   * @memberof CoreapiKeyPair
   */
  pub?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiKeyPair
   */
  pvt?: string
}
/**
 *
 * @export
 * @interface CoreapiMintNFTOnCCRequest
 */
export interface CoreapiMintNFTOnCCRequest {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   * @type {string}
   * @memberof CoreapiMintNFTOnCCRequest
   */
  depositAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTOnCCRequest
   */
  documentId?: string
  /**
   *
   * @type {Array<string>}
   * @memberof CoreapiMintNFTOnCCRequest
   */
  proofFields?: Array<string>
}
/**
 *
 * @export
 * @interface CoreapiMintNFTOnCCResponse
 */
export interface CoreapiMintNFTOnCCResponse {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   * @type {string}
   * @memberof CoreapiMintNFTOnCCResponse
   */
  depositAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTOnCCResponse
   */
  documentId?: string
  /**
   *
   * @type {CoreapiNFTResponseHeader}
   * @memberof CoreapiMintNFTOnCCResponse
   */
  header?: CoreapiNFTResponseHeader
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTOnCCResponse
   */
  registryAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTOnCCResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiMintNFTRequest
 */
export interface CoreapiMintNFTRequest {
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTRequest
   */
  asset_manager_address?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTRequest
   */
  deposit_address?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTRequest
   */
  document_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof CoreapiMintNFTRequest
   */
  proof_fields?: Array<string>
}
/**
 *
 * @export
 * @interface CoreapiMintNFTResponse
 */
export interface CoreapiMintNFTResponse {
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTResponse
   */
  depositAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTResponse
   */
  documentId?: string
  /**
   *
   * @type {CoreapiNFTResponseHeader}
   * @memberof CoreapiMintNFTResponse
   */
  header?: CoreapiNFTResponseHeader
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTResponse
   */
  registryAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMintNFTResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiMonetaryValue
 */
export interface CoreapiMonetaryValue {
  /**
   *
   * @type {string}
   * @memberof CoreapiMonetaryValue
   */
  chainId?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMonetaryValue
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiMonetaryValue
   */
  value?: string
}
/**
 *
 * @export
 * @interface CoreapiNFT
 */
export interface CoreapiNFT {
  /**
   *
   * @type {string}
   * @memberof CoreapiNFT
   */
  owner?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFT
   */
  registry?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFT
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiNFTOwnerOnCCResponse
 */
export interface CoreapiNFTOwnerOnCCResponse {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   * @type {string}
   * @memberof CoreapiNFTOwnerOnCCResponse
   */
  owner?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFTOwnerOnCCResponse
   */
  registryAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFTOwnerOnCCResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiNFTOwnerResponse
 */
export interface CoreapiNFTOwnerResponse {
  /**
   * 20 byte hex encoded ethereum address
   * @type {string}
   * @memberof CoreapiNFTOwnerResponse
   */
  owner?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFTOwnerResponse
   */
  registryAddress?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiNFTOwnerResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiNFTResponseHeader
 */
export interface CoreapiNFTResponseHeader {
  /**
   *
   * @type {string}
   * @memberof CoreapiNFTResponseHeader
   */
  jobId?: string
}
/**
 *
 * @export
 * @interface CoreapiProofResponseHeader
 */
export interface CoreapiProofResponseHeader {
  /**
   *
   * @type {string}
   * @memberof CoreapiProofResponseHeader
   */
  documentId?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiProofResponseHeader
   */
  state?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiProofResponseHeader
   */
  versionId?: string
}
/**
 *
 * @export
 * @interface CoreapiProofsRequest
 */
export interface CoreapiProofsRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof CoreapiProofsRequest
   */
  fields?: Array<string>
}
/**
 *
 * @export
 * @interface CoreapiProofsResponse
 */
export interface CoreapiProofsResponse {
  /**
   *
   * @type {Array<DocumentsProof>}
   * @memberof CoreapiProofsResponse
   */
  fieldProofs?: Array<DocumentsProof>
  /**
   *
   * @type {CoreapiProofResponseHeader}
   * @memberof CoreapiProofsResponse
   */
  header?: CoreapiProofResponseHeader
}
/**
 *
 * @export
 * @interface CoreapiResponseHeader
 */
export interface CoreapiResponseHeader {
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  author?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  document_id?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  fingerprint?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  job_id?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  nextVersionId?: string
  /**
   *
   * @type {Array<CoreapiNFT>}
   * @memberof CoreapiResponseHeader
   */
  nfts?: Array<CoreapiNFT>
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  previousVersionId?: string
  /**
   *
   * @type {Array<string>}
   * @memberof CoreapiResponseHeader
   */
  readAccess?: Array<string>
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiResponseHeader
   */
  versionId?: string
  /**
   *
   * @type {Array<string>}
   * @memberof CoreapiResponseHeader
   */
  writeAccess?: Array<string>
}
/**
 *
 * @export
 * @interface CoreapiSignRequest
 */
export interface CoreapiSignRequest {
  /**
   *
   * @type {string}
   * @memberof CoreapiSignRequest
   */
  payload?: string
}
/**
 *
 * @export
 * @interface CoreapiSignResponse
 */
export interface CoreapiSignResponse {
  /**
   *
   * @type {string}
   * @memberof CoreapiSignResponse
   */
  payload?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiSignResponse
   */
  publicKey?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiSignResponse
   */
  signature?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiSignResponse
   */
  signerId?: string
}
/**
 *
 * @export
 * @interface CoreapiSignedValue
 */
export interface CoreapiSignedValue {
  /**
   *
   * @type {string}
   * @memberof CoreapiSignedValue
   */
  identity?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiSignedValue
   */
  value?: string
}
/**
 *
 * @export
 * @interface CoreapiTransferNFTOnCCRequest
 */
export interface CoreapiTransferNFTOnCCRequest {
  /**
   * 32 byte hex encoded account id on centrifuge chain
   * @type {string}
   * @memberof CoreapiTransferNFTOnCCRequest
   */
  to?: string
}
/**
 *
 * @export
 * @interface CoreapiTransferNFTOnCCResponse
 */
export interface CoreapiTransferNFTOnCCResponse {
  /**
   *
   * @type {CoreapiNFTResponseHeader}
   * @memberof CoreapiTransferNFTOnCCResponse
   */
  header?: CoreapiNFTResponseHeader
  /**
   *
   * @type {string}
   * @memberof CoreapiTransferNFTOnCCResponse
   */
  registryAddress?: string
  /**
   * 32 byte hex encoded account id on centrifuge chain
   * @type {string}
   * @memberof CoreapiTransferNFTOnCCResponse
   */
  to?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiTransferNFTOnCCResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface CoreapiTransferNFTRequest
 */
export interface CoreapiTransferNFTRequest {
  /**
   * 20 byte hex encoded ethereum address
   * @type {string}
   * @memberof CoreapiTransferNFTRequest
   */
  to?: string
}
/**
 *
 * @export
 * @interface CoreapiTransferNFTResponse
 */
export interface CoreapiTransferNFTResponse {
  /**
   *
   * @type {CoreapiNFTResponseHeader}
   * @memberof CoreapiTransferNFTResponse
   */
  header?: CoreapiNFTResponseHeader
  /**
   *
   * @type {string}
   * @memberof CoreapiTransferNFTResponse
   */
  registryAddress?: string
  /**
   * 20 byte hex encoded ethereum address
   * @type {string}
   * @memberof CoreapiTransferNFTResponse
   */
  to?: string
  /**
   *
   * @type {string}
   * @memberof CoreapiTransferNFTResponse
   */
  tokenId?: string
}
/**
 *
 * @export
 * @interface DocumentsProof
 */
export interface DocumentsProof {
  /**
   *
   * @type {string}
   * @memberof DocumentsProof
   */
  hash?: string
  /**
   *
   * @type {string}
   * @memberof DocumentsProof
   */
  property?: string
  /**
   *
   * @type {string}
   * @memberof DocumentsProof
   */
  salt?: string
  /**
   *
   * @type {Array<string>}
   * @memberof DocumentsProof
   */
  sortedHashes?: Array<string>
  /**
   *
   * @type {string}
   * @memberof DocumentsProof
   */
  value?: string
}
/**
 *
 * @export
 * @interface GoceleryTask
 */
export interface GoceleryTask {
  /**
   * arguments passed to this task
   * @type {Array<any>}
   * @memberof GoceleryTask
   */
  args?: Array<any>
  /**
   * delay until ready to be run
   * @type {string}
   * @memberof GoceleryTask
   */
  delay?: string
  /**
   * error after task run
   * @type {string}
   * @memberof GoceleryTask
   */
  error?: string
  /**
   * result after the task run
   * @type {any}
   * @memberof GoceleryTask
   */
  result?: any
  /**
   * name of the runnerFuncs
   * @type {string}
   * @memberof GoceleryTask
   */
  runnerFuncs?: string
  /**
   * number of times task was run.
   * @type {number}
   * @memberof GoceleryTask
   */
  tries?: number
}
/**
 *
 * @export
 * @interface HealthPong
 */
export interface HealthPong {
  /**
   *
   * @type {string}
   * @memberof HealthPong
   */
  network?: string
  /**
   *
   * @type {string}
   * @memberof HealthPong
   */
  version?: string
}
/**
 *
 * @export
 * @interface HttputilsHTTPError
 */
export interface HttputilsHTTPError {
  /**
   *
   * @type {string}
   * @memberof HttputilsHTTPError
   */
  message?: string
}
/**
 *
 * @export
 * @interface NotificationDocumentMessage
 */
export interface NotificationDocumentMessage {
  /**
   * document received from
   * @type {string}
   * @memberof NotificationDocumentMessage
   */
  from?: string
  /**
   * document identifier
   * @type {string}
   * @memberof NotificationDocumentMessage
   */
  id?: string
  /**
   * document sent to
   * @type {string}
   * @memberof NotificationDocumentMessage
   */
  to?: string
  /**
   * version identifier
   * @type {string}
   * @memberof NotificationDocumentMessage
   */
  versionId?: string
}
/**
 *
 * @export
 * @interface NotificationJobMessage
 */
export interface NotificationJobMessage {
  /**
   * description of the job
   * @type {string}
   * @memberof NotificationJobMessage
   */
  desc?: string
  /**
   * job finished at
   * @type {string}
   * @memberof NotificationJobMessage
   */
  finishedAt?: string
  /**
   * job identifier
   * @type {string}
   * @memberof NotificationJobMessage
   */
  id?: string
  /**
   * job owner
   * @type {string}
   * @memberof NotificationJobMessage
   */
  owner?: string
  /**
   * validity of the job
   * @type {string}
   * @memberof NotificationJobMessage
   */
  validUntil?: string
}
/**
 *
 * @export
 * @interface NotificationMessage
 */
export interface NotificationMessage {
  /**
   *
   * @type {NotificationDocumentMessage}
   * @memberof NotificationMessage
   */
  document?: NotificationDocumentMessage
  /**
   *
   * @type {string}
   * @memberof NotificationMessage
   */
  eventType?: NotificationMessage.EventTypeEnum
  /**
   *
   * @type {NotificationJobMessage}
   * @memberof NotificationMessage
   */
  job?: NotificationJobMessage
  /**
   *
   * @type {string}
   * @memberof NotificationMessage
   */
  recordedAt?: string
}

/**
 * @export
 * @namespace NotificationMessage
 */
export namespace NotificationMessage {
  /**
   * @export
   * @enum {string}
   */
  export enum EventTypeEnum {
    Job = <any>'job',
    Document = <any>'document',
  }
}
/**
 *
 * @export
 * @interface OraclePushAttributeToOracleRequest
 */
export interface OraclePushAttributeToOracleRequest {
  /**
   * hex value of the Attribute key
   * @type {string}
   * @memberof OraclePushAttributeToOracleRequest
   */
  attribute_key?: string
  /**
   * hex value of the Oracle address
   * @type {string}
   * @memberof OraclePushAttributeToOracleRequest
   */
  oracle_address?: string
  /**
   * hex value of the NFT token
   * @type {string}
   * @memberof OraclePushAttributeToOracleRequest
   */
  token_id?: string
}
/**
 *
 * @export
 * @interface OraclePushToOracleResponse
 */
export interface OraclePushToOracleResponse {
  /**
   * hex value of the Attribute key
   * @type {string}
   * @memberof OraclePushToOracleResponse
   */
  attribute_key?: string
  /**
   *
   * @type {string}
   * @memberof OraclePushToOracleResponse
   */
  job_id?: string
  /**
   * hex value of the Oracle address
   * @type {string}
   * @memberof OraclePushToOracleResponse
   */
  oracle_address?: string
  /**
   * hex value of the NFT token
   * @type {string}
   * @memberof OraclePushToOracleResponse
   */
  token_id?: string
}
/**
 *
 * @export
 * @interface PendingAddTransitionRules
 */
export interface PendingAddTransitionRules {
  /**
   *
   * @type {Array<PendingAttributeRule>}
   * @memberof PendingAddTransitionRules
   */
  attributeRules?: Array<PendingAttributeRule>
  /**
   *
   * @type {Array<PendingComputeFieldsRule>}
   * @memberof PendingAddTransitionRules
   */
  computeFieldsRules?: Array<PendingComputeFieldsRule>
}
/**
 *
 * @export
 * @interface PendingAttributeRule
 */
export interface PendingAttributeRule {
  /**
   * attribute key label
   * @type {string}
   * @memberof PendingAttributeRule
   */
  keyLabel?: string
  /**
   * roleID is 32 byte role ID in hex. RoleID should already be part of the document.
   * @type {string}
   * @memberof PendingAttributeRule
   */
  roleId?: string
}
/**
 *
 * @export
 * @interface PendingComputeFieldsRule
 */
export interface PendingComputeFieldsRule {
  /**
   * AttributeLabels that are passed to the WASM for execution
   * @type {Array<string>}
   * @memberof PendingComputeFieldsRule
   */
  attributeLabels?: Array<string>
  /**
   * TargetAttributeLabel is the label of the attribute which holds the result from the executed WASM. This attribute is automatically added and updated everytime document is updated.
   * @type {string}
   * @memberof PendingComputeFieldsRule
   */
  targetAttributeLabel?: string
  /**
   *
   * @type {string}
   * @memberof PendingComputeFieldsRule
   */
  wasm?: string
}
/**
 *
 * @export
 * @interface V2AddRole
 */
export interface V2AddRole {
  /**
   *
   * @type {Array<string>}
   * @memberof V2AddRole
   */
  collaborators?: Array<string>
  /**
   * Key is either hex encoded 32 byte ID or string label. String label is used as a preimage to sha256 for 32 byte hash.
   * @type {string}
   * @memberof V2AddRole
   */
  key?: string
}
/**
 *
 * @export
 * @interface V2CloneDocumentRequest
 */
export interface V2CloneDocumentRequest {
  /**
   *
   * @type {string}
   * @memberof V2CloneDocumentRequest
   */
  scheme?: V2CloneDocumentRequest.SchemeEnum
}

/**
 * @export
 * @namespace V2CloneDocumentRequest
 */
export namespace V2CloneDocumentRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
/**
 *
 * @export
 * @interface V2CreateDocumentRequest
 */
export interface V2CreateDocumentRequest {
  /**
   *
   * @type {CoreapiAttributeMapRequest}
   * @memberof V2CreateDocumentRequest
   */
  attributes?: CoreapiAttributeMapRequest
  /**
   *
   * @type {any}
   * @memberof V2CreateDocumentRequest
   */
  data?: any
  /**
   * if provided, creates the next version of the document.
   * @type {string}
   * @memberof V2CreateDocumentRequest
   */
  documentId?: string
  /**
   *
   * @type {Array<string>}
   * @memberof V2CreateDocumentRequest
   */
  readAccess?: Array<string>
  /**
   *
   * @type {string}
   * @memberof V2CreateDocumentRequest
   */
  scheme?: V2CreateDocumentRequest.SchemeEnum
  /**
   *
   * @type {Array<string>}
   * @memberof V2CreateDocumentRequest
   */
  writeAccess?: Array<string>
}

/**
 * @export
 * @namespace V2CreateDocumentRequest
 */
export namespace V2CreateDocumentRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
/**
 *
 * @export
 * @interface V2GenerateAccountResponse
 */
export interface V2GenerateAccountResponse {
  /**
   *
   * @type {string}
   * @memberof V2GenerateAccountResponse
   */
  did?: string
  /**
   *
   * @type {string}
   * @memberof V2GenerateAccountResponse
   */
  jobId?: string
}
/**
 *
 * @export
 * @interface V2Job
 */
export interface V2Job {
  /**
   * Job Identifier
   * @type {string}
   * @memberof V2Job
   */
  jobID?: string
  /**
   * description of the Job
   * @type {string}
   * @memberof V2Job
   */
  desc?: string
  /**
   * job status
   * @type {boolean}
   * @memberof V2Job
   */
  finished?: boolean
  /**
   * Job finished at. If empty, job is not complete yet
   * @type {string}
   * @memberof V2Job
   */
  finishedAt?: string
  /**
   * overrides for the Job
   * @type {any}
   * @memberof V2Job
   */
  overrides?: any
  /**
   * name of the Runner
   * @type {string}
   * @memberof V2Job
   */
  runner?: string
  /**
   * list of tasks ran under this Job
   * @type {Array<GoceleryTask>}
   * @memberof V2Job
   */
  tasks?: Array<GoceleryTask>
  /**
   * validity of the job
   * @type {string}
   * @memberof V2Job
   */
  validUntil?: string
}
/**
 *
 * @export
 * @interface V2RemoveCollaboratorsRequest
 */
export interface V2RemoveCollaboratorsRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof V2RemoveCollaboratorsRequest
   */
  collaborators?: Array<string>
}
/**
 *
 * @export
 * @interface V2Role
 */
export interface V2Role {
  /**
   *
   * @type {Array<string>}
   * @memberof V2Role
   */
  collaborators?: Array<string>
  /**
   *
   * @type {string}
   * @memberof V2Role
   */
  id?: string
}
/**
 *
 * @export
 * @interface V2SignedAttributeRequest
 */
export interface V2SignedAttributeRequest {
  /**
   *
   * @type {string}
   * @memberof V2SignedAttributeRequest
   */
  label?: string
  /**
   *
   * @type {string}
   * @memberof V2SignedAttributeRequest
   */
  payload?: string
  /**
   *
   * @type {string}
   * @memberof V2SignedAttributeRequest
   */
  type?: V2SignedAttributeRequest.TypeEnum
}

/**
 * @export
 * @namespace V2SignedAttributeRequest
 */
export namespace V2SignedAttributeRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Integer = <any>'integer',
    String = <any>'string',
    Bytes = <any>'bytes',
    Timestamp = <any>'timestamp',
  }
}
/**
 *
 * @export
 * @interface V2TransitionRule
 */
export interface V2TransitionRule {
  /**
   *
   * @type {string}
   * @memberof V2TransitionRule
   */
  action?: string
  /**
   *
   * @type {Array<string>}
   * @memberof V2TransitionRule
   */
  attributeLabels?: Array<string>
  /**
   *
   * @type {string}
   * @memberof V2TransitionRule
   */
  field?: string
  /**
   *
   * @type {Array<string>}
   * @memberof V2TransitionRule
   */
  roles?: Array<string>
  /**
   *
   * @type {string}
   * @memberof V2TransitionRule
   */
  ruleId?: string
  /**
   *
   * @type {string}
   * @memberof V2TransitionRule
   */
  targetAttributeLabel?: string
  /**
   *
   * @type {string}
   * @memberof V2TransitionRule
   */
  wasm?: string
}
/**
 *
 * @export
 * @interface V2TransitionRules
 */
export interface V2TransitionRules {
  /**
   *
   * @type {Array<V2TransitionRule>}
   * @memberof V2TransitionRules
   */
  rules?: Array<V2TransitionRule>
}
/**
 *
 * @export
 * @interface V2UpdateDocumentRequest
 */
export interface V2UpdateDocumentRequest {
  /**
   *
   * @type {CoreapiAttributeMapRequest}
   * @memberof V2UpdateDocumentRequest
   */
  attributes?: CoreapiAttributeMapRequest
  /**
   *
   * @type {any}
   * @memberof V2UpdateDocumentRequest
   */
  data?: any
  /**
   *
   * @type {Array<string>}
   * @memberof V2UpdateDocumentRequest
   */
  readAccess?: Array<string>
  /**
   *
   * @type {string}
   * @memberof V2UpdateDocumentRequest
   */
  scheme?: V2UpdateDocumentRequest.SchemeEnum
  /**
   *
   * @type {Array<string>}
   * @memberof V2UpdateDocumentRequest
   */
  writeAccess?: Array<string>
}

/**
 * @export
 * @namespace V2UpdateDocumentRequest
 */
export namespace V2UpdateDocumentRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum SchemeEnum {
    Generic = <any>'generic',
    Entity = <any>'entity',
  }
}
/**
 *
 * @export
 * @interface V2UpdateRole
 */
export interface V2UpdateRole {
  /**
   *
   * @type {Array<string>}
   * @memberof V2UpdateRole
   */
  collaborators?: Array<string>
}
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Signs and returns the signature of the Payload.
     * @summary Signs and returns the signature of the Payload.
     * @param {CoreapiSignRequest} body Sign request
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountSign(body: CoreapiSignRequest, accountId: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling accountSign.')
      }
      // verify required parameter 'accountId' is not null or undefined
      if (accountId === null || accountId === undefined) {
        throw new RequiredError(
          'accountId',
          'Required parameter accountId was null or undefined when calling accountSign.'
        )
      }
      const localVarPath = `/v2/accounts/{account_id}/sign`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiSignRequest' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates a new account with defaults.
     * @summary Generates a new account with defaults.
     * @param {CoreapiGenerateAccountPayload} body Generate Account Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAccountV2(body: CoreapiGenerateAccountPayload, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling generateAccountV2.')
      }
      const localVarPath = `/v2/accounts/generate`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiGenerateAccountPayload' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the account associated with accountID.
     * @summary Returns the account associated with accountID.
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options: any = {}): FetchArgs {
      // verify required parameter 'accountId' is not null or undefined
      if (accountId === null || accountId === undefined) {
        throw new RequiredError(
          'accountId',
          'Required parameter accountId was null or undefined when calling getAccount.'
        )
      }
      const localVarPath = `/v2/accounts/{account_id}`.replace(
        `{${'account_id'}}`,
        encodeURIComponent(String(accountId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns all the accounts in the node.
     * @summary Returns all the accounts in the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(options: any = {}): FetchArgs {
      const localVarPath = `/v2/accounts`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Signs and returns the signature of the Payload.
     * @summary Signs and returns the signature of the Payload.
     * @param {CoreapiSignRequest} body Sign request
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountSign(
      body: CoreapiSignRequest,
      accountId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiSignResponse> {
      const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).accountSign(body, accountId, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Generates a new account with defaults.
     * @summary Generates a new account with defaults.
     * @param {CoreapiGenerateAccountPayload} body Generate Account Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAccountV2(
      body: CoreapiGenerateAccountPayload,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2GenerateAccountResponse> {
      const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).generateAccountV2(body, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the account associated with accountID.
     * @summary Returns the account associated with accountID.
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiAccount> {
      const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccount(accountId, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns all the accounts in the node.
     * @summary Returns all the accounts in the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiAccounts> {
      const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccounts(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Signs and returns the signature of the Payload.
     * @summary Signs and returns the signature of the Payload.
     * @param {CoreapiSignRequest} body Sign request
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountSign(body: CoreapiSignRequest, accountId: string, options?: any) {
      return AccountsApiFp(configuration).accountSign(body, accountId, options)(fetch, basePath)
    },
    /**
     * Generates a new account with defaults.
     * @summary Generates a new account with defaults.
     * @param {CoreapiGenerateAccountPayload} body Generate Account Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAccountV2(body: CoreapiGenerateAccountPayload, options?: any) {
      return AccountsApiFp(configuration).generateAccountV2(body, options)(fetch, basePath)
    },
    /**
     * Returns the account associated with accountID.
     * @summary Returns the account associated with accountID.
     * @param {string} accountId Account ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any) {
      return AccountsApiFp(configuration).getAccount(accountId, options)(fetch, basePath)
    },
    /**
     * Returns all the accounts in the node.
     * @summary Returns all the accounts in the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(options?: any) {
      return AccountsApiFp(configuration).getAccounts(options)(fetch, basePath)
    },
  }
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Signs and returns the signature of the Payload.
   * @summary Signs and returns the signature of the Payload.
   * @param {CoreapiSignRequest} body Sign request
   * @param {string} accountId Account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountSign(body: CoreapiSignRequest, accountId: string, options?: any) {
    return AccountsApiFp(this.configuration).accountSign(body, accountId, options)(this.fetch, this.basePath)
  }

  /**
   * Generates a new account with defaults.
   * @summary Generates a new account with defaults.
   * @param {CoreapiGenerateAccountPayload} body Generate Account Payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public generateAccountV2(body: CoreapiGenerateAccountPayload, options?: any) {
    return AccountsApiFp(this.configuration).generateAccountV2(body, options)(this.fetch, this.basePath)
  }

  /**
   * Returns the account associated with accountID.
   * @summary Returns the account associated with accountID.
   * @param {string} accountId Account ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccount(accountId: string, options?: any) {
    return AccountsApiFp(this.configuration).getAccount(accountId, options)(this.fetch, this.basePath)
  }

  /**
   * Returns all the accounts in the node.
   * @summary Returns all the accounts in the node.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccounts(options?: any) {
    return AccountsApiFp(this.configuration).getAccounts(options)(this.fetch, this.basePath)
  }
}
/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Add attributes to pending document.
     * @summary Add attributes to pending document.
     * @param {{ [key: string]: CoreapiAttributeRequest; }} body Attributes
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAttributes(
      body: { [key: string]: CoreapiAttributeRequest },
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling addAttributes.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling addAttributes.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling addAttributes.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/attributes`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'{ [key: string]: CoreapiAttributeRequest; }' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Adds a new role to the document.
     * @summary Adds a new role to the document.
     * @param {V2AddRole} body Add Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRole(body: V2AddRole, authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling addRole.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling addRole.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling addRole.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/roles`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2AddRole' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Signs the given payload and add it the pending document.
     * @summary Signs the given payload and add it the pending document.
     * @param {V2SignedAttributeRequest} body Signed Attribute request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSignedAttribute(
      body: V2SignedAttributeRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addSignedAttribute.'
        )
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling addSignedAttribute.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling addSignedAttribute.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/signed_attribute`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2SignedAttributeRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Adds a new transition rules to the document.
     * @summary Adds a transition new rules to the document.
     * @param {PendingAddTransitionRules} body Add Transition rules Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTransitionRule(
      body: PendingAddTransitionRules,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling addTransitionRule.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling addTransitionRule.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling addTransitionRule.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/transition_rules`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'PendingAddTransitionRules' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new cloned document from an existing Template document.
     * @summary Creates a new cloned document from an existing Template document.
     * @param {V2CloneDocumentRequest} body Document Clone request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneDocumentV2(
      body: V2CloneDocumentRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling cloneDocumentV2.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling cloneDocumentV2.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling cloneDocumentV2.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/clone`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2CloneDocumentRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Commits a pending document.
     * @summary Commits a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitDocumentV2(authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling commitDocumentV2.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling commitDocumentV2.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/commit`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new document.
     * @summary Creates a new document.
     * @param {V2CreateDocumentRequest} body Document Create request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDocumentV2(body: V2CreateDocumentRequest, authorization: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling createDocumentV2.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling createDocumentV2.'
        )
      }
      const localVarPath = `/v2/documents`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2CreateDocumentRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes attribute on a pending document.
     * @summary Deletes attribute on a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} attributeKey Hex encoded attribute key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute(authorization: string, documentId: string, attributeKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling deleteAttribute.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling deleteAttribute.'
        )
      }
      // verify required parameter 'attributeKey' is not null or undefined
      if (attributeKey === null || attributeKey === undefined) {
        throw new RequiredError(
          'attributeKey',
          'Required parameter attributeKey was null or undefined when calling deleteAttribute.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/attributes/{attribute_key}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'attribute_key'}}`, encodeURIComponent(String(attributeKey)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes the transition rule associated with ruleID from the document.
     * @summary Deletes the transition rule associated with ruleID from the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransitionRule(authorization: string, documentId: string, ruleId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling deleteTransitionRule.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling deleteTransitionRule.'
        )
      }
      // verify required parameter 'ruleId' is not null or undefined
      if (ruleId === null || ruleId === undefined) {
        throw new RequiredError(
          'ruleId',
          'Required parameter ruleId was null or undefined when calling deleteTransitionRule.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/transition_rules/{rule_id}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'rule_id'}}`, encodeURIComponent(String(ruleId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates proofs for the fields from latest version of the document.
     * @summary Generates proofs for the fields from latest version of the document.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentProofs(
      body: CoreapiProofsRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling generateDocumentProofs.'
        )
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling generateDocumentProofs.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling generateDocumentProofs.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/proofs`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiProofsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates proofs for the fields from a specific document version.
     * @summary Generates proofs for the fields from a specific document version.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentVersionProofs(
      body: CoreapiProofsRequest,
      authorization: string,
      documentId: string,
      versionId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling generateDocumentVersionProofs.'
        )
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling generateDocumentVersionProofs.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling generateDocumentVersionProofs.'
        )
      }
      // verify required parameter 'versionId' is not null or undefined
      if (versionId === null || versionId === undefined) {
        throw new RequiredError(
          'versionId',
          'Required parameter versionId was null or undefined when calling generateDocumentVersionProofs.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/versions/{version_id}/proofs`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'version_id'}}`, encodeURIComponent(String(versionId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiProofsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the latest committed document associated with docID.
     * @summary Returns the latest committed document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittedDocument(authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getCommittedDocument.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getCommittedDocument.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/committed`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the specific version of the document.
     * @summary Returns the specific version of the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentVersionV2(authorization: string, documentId: string, versionId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getDocumentVersionV2.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getDocumentVersionV2.'
        )
      }
      // verify required parameter 'versionId' is not null or undefined
      if (versionId === null || versionId === undefined) {
        throw new RequiredError(
          'versionId',
          'Required parameter versionId was null or undefined when calling getDocumentVersionV2.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/versions/{version_id}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'version_id'}}`, encodeURIComponent(String(versionId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the entity relationships.
     * @summary Returns the entity relationships.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityRelationships(authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getEntityRelationships.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getEntityRelationships.'
        )
      }
      const localVarPath = `/v2/entities/{document_id}/relationships`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the latest version of the Entity through relationship ID.
     * @summary Returns the latest version of the Entity through relationship ID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Entity Relationship Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityThroughRelationshipId(authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getEntityThroughRelationshipId.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getEntityThroughRelationshipId.'
        )
      }
      const localVarPath = `/v2/relationships/{document_id}/entity`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the pending document associated with docID.
     * @summary Returns the pending document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingDocument(authorization: string, documentId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getPendingDocument.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getPendingDocument.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/pending`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the role associated with the role ID in the document.
     * @summary Returns the role associated with the role ID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(authorization: string, documentId: string, roleId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getRole.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getRole.'
        )
      }
      // verify required parameter 'roleId' is not null or undefined
      if (roleId === null || roleId === undefined) {
        throw new RequiredError('roleId', 'Required parameter roleId was null or undefined when calling getRole.')
      }
      const localVarPath = `/v2/documents/{document_id}/roles/{role_id}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'role_id'}}`, encodeURIComponent(String(roleId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the rule associated with the ruleID in the document.
     * @summary Returns the rule associated with the ruleID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransitionRule(authorization: string, documentId: string, ruleId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getTransitionRule.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling getTransitionRule.'
        )
      }
      // verify required parameter 'ruleId' is not null or undefined
      if (ruleId === null || ruleId === undefined) {
        throw new RequiredError(
          'ruleId',
          'Required parameter ruleId was null or undefined when calling getTransitionRule.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/transition_rules/{rule_id}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'rule_id'}}`, encodeURIComponent(String(ruleId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Removes the collaborators from the document.
     * @summary Removes the collaborators from the document.
     * @param {V2RemoveCollaboratorsRequest} body Remove Collaborators request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCollaborators(
      body: V2RemoveCollaboratorsRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling removeCollaborators.'
        )
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling removeCollaborators.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling removeCollaborators.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/collaborators`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2RemoveCollaboratorsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a pending document.
     * @summary Updates a pending document.
     * @param {V2UpdateDocumentRequest} body Document Update request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDocumentV2(
      body: V2UpdateDocumentRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateDocumentV2.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling updateDocumentV2.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling updateDocumentV2.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2UpdateDocumentRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates an existing role on the document.
     * @summary Updates an existing role on the document.
     * @param {V2UpdateRole} body Update Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(
      body: V2UpdateRole,
      authorization: string,
      documentId: string,
      roleId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateRole.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling updateRole.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling updateRole.'
        )
      }
      // verify required parameter 'roleId' is not null or undefined
      if (roleId === null || roleId === undefined) {
        throw new RequiredError('roleId', 'Required parameter roleId was null or undefined when calling updateRole.')
      }
      const localVarPath = `/v2/documents/{document_id}/roles/{role_id}`
        .replace(`{${'document_id'}}`, encodeURIComponent(String(documentId)))
        .replace(`{${'role_id'}}`, encodeURIComponent(String(roleId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'V2UpdateRole' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add attributes to pending document.
     * @summary Add attributes to pending document.
     * @param {{ [key: string]: CoreapiAttributeRequest; }} body Attributes
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAttributes(
      body: { [key: string]: CoreapiAttributeRequest },
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addAttributes(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Adds a new role to the document.
     * @summary Adds a new role to the document.
     * @param {V2AddRole} body Add Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRole(
      body: V2AddRole,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2Role> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addRole(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Signs the given payload and add it the pending document.
     * @summary Signs the given payload and add it the pending document.
     * @param {V2SignedAttributeRequest} body Signed Attribute request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSignedAttribute(
      body: V2SignedAttributeRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addSignedAttribute(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Adds a new transition rules to the document.
     * @summary Adds a transition new rules to the document.
     * @param {PendingAddTransitionRules} body Add Transition rules Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTransitionRule(
      body: PendingAddTransitionRules,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2TransitionRules> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addTransitionRule(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Creates a new cloned document from an existing Template document.
     * @summary Creates a new cloned document from an existing Template document.
     * @param {V2CloneDocumentRequest} body Document Clone request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneDocumentV2(
      body: V2CloneDocumentRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).cloneDocumentV2(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Commits a pending document.
     * @summary Commits a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitDocumentV2(
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).commitDocumentV2(
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Creates a new document.
     * @summary Creates a new document.
     * @param {V2CreateDocumentRequest} body Document Create request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDocumentV2(
      body: V2CreateDocumentRequest,
      authorization: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).createDocumentV2(
        body,
        authorization,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Deletes attribute on a pending document.
     * @summary Deletes attribute on a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} attributeKey Hex encoded attribute key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute(
      authorization: string,
      documentId: string,
      attributeKey: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteAttribute(
        authorization,
        documentId,
        attributeKey,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Deletes the transition rule associated with ruleID from the document.
     * @summary Deletes the transition rule associated with ruleID from the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransitionRule(
      authorization: string,
      documentId: string,
      ruleId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteTransitionRule(
        authorization,
        documentId,
        ruleId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Generates proofs for the fields from latest version of the document.
     * @summary Generates proofs for the fields from latest version of the document.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentProofs(
      body: CoreapiProofsRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiProofsResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).generateDocumentProofs(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Generates proofs for the fields from a specific document version.
     * @summary Generates proofs for the fields from a specific document version.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentVersionProofs(
      body: CoreapiProofsRequest,
      authorization: string,
      documentId: string,
      versionId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiProofsResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).generateDocumentVersionProofs(
        body,
        authorization,
        documentId,
        versionId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the latest committed document associated with docID.
     * @summary Returns the latest committed document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittedDocument(
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getCommittedDocument(
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the specific version of the document.
     * @summary Returns the specific version of the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentVersionV2(
      authorization: string,
      documentId: string,
      versionId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getDocumentVersionV2(
        authorization,
        documentId,
        versionId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the entity relationships.
     * @summary Returns the entity relationships.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityRelationships(
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CoreapiDocumentResponse>> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getEntityRelationships(
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the latest version of the Entity through relationship ID.
     * @summary Returns the latest version of the Entity through relationship ID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Entity Relationship Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityThroughRelationshipId(
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getEntityThroughRelationshipId(
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the pending document associated with docID.
     * @summary Returns the pending document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingDocument(
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getPendingDocument(
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the role associated with the role ID in the document.
     * @summary Returns the role associated with the role ID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(
      authorization: string,
      documentId: string,
      roleId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2Role> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getRole(
        authorization,
        documentId,
        roleId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the rule associated with the ruleID in the document.
     * @summary Returns the rule associated with the ruleID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransitionRule(
      authorization: string,
      documentId: string,
      ruleId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2TransitionRule> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getTransitionRule(
        authorization,
        documentId,
        ruleId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Removes the collaborators from the document.
     * @summary Removes the collaborators from the document.
     * @param {V2RemoveCollaboratorsRequest} body Remove Collaborators request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCollaborators(
      body: V2RemoveCollaboratorsRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).removeCollaborators(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Updates a pending document.
     * @summary Updates a pending document.
     * @param {V2UpdateDocumentRequest} body Document Update request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDocumentV2(
      body: V2UpdateDocumentRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiDocumentResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).updateDocumentV2(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Updates an existing role on the document.
     * @summary Updates an existing role on the document.
     * @param {V2UpdateRole} body Update Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(
      body: V2UpdateRole,
      authorization: string,
      documentId: string,
      roleId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2Role> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).updateRole(
        body,
        authorization,
        documentId,
        roleId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Add attributes to pending document.
     * @summary Add attributes to pending document.
     * @param {{ [key: string]: CoreapiAttributeRequest; }} body Attributes
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAttributes(
      body: { [key: string]: CoreapiAttributeRequest },
      authorization: string,
      documentId: string,
      options?: any
    ) {
      return DocumentsApiFp(configuration).addAttributes(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Adds a new role to the document.
     * @summary Adds a new role to the document.
     * @param {V2AddRole} body Add Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addRole(body: V2AddRole, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).addRole(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Signs the given payload and add it the pending document.
     * @summary Signs the given payload and add it the pending document.
     * @param {V2SignedAttributeRequest} body Signed Attribute request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addSignedAttribute(body: V2SignedAttributeRequest, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).addSignedAttribute(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Adds a new transition rules to the document.
     * @summary Adds a transition new rules to the document.
     * @param {PendingAddTransitionRules} body Add Transition rules Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTransitionRule(body: PendingAddTransitionRules, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).addTransitionRule(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Creates a new cloned document from an existing Template document.
     * @summary Creates a new cloned document from an existing Template document.
     * @param {V2CloneDocumentRequest} body Document Clone request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneDocumentV2(body: V2CloneDocumentRequest, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).cloneDocumentV2(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Commits a pending document.
     * @summary Commits a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitDocumentV2(authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).commitDocumentV2(authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Creates a new document.
     * @summary Creates a new document.
     * @param {V2CreateDocumentRequest} body Document Create request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDocumentV2(body: V2CreateDocumentRequest, authorization: string, options?: any) {
      return DocumentsApiFp(configuration).createDocumentV2(body, authorization, options)(fetch, basePath)
    },
    /**
     * Deletes attribute on a pending document.
     * @summary Deletes attribute on a pending document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} attributeKey Hex encoded attribute key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttribute(authorization: string, documentId: string, attributeKey: string, options?: any) {
      return DocumentsApiFp(configuration).deleteAttribute(
        authorization,
        documentId,
        attributeKey,
        options
      )(fetch, basePath)
    },
    /**
     * Deletes the transition rule associated with ruleID from the document.
     * @summary Deletes the transition rule associated with ruleID from the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransitionRule(authorization: string, documentId: string, ruleId: string, options?: any) {
      return DocumentsApiFp(configuration).deleteTransitionRule(
        authorization,
        documentId,
        ruleId,
        options
      )(fetch, basePath)
    },
    /**
     * Generates proofs for the fields from latest version of the document.
     * @summary Generates proofs for the fields from latest version of the document.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentProofs(body: CoreapiProofsRequest, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).generateDocumentProofs(
        body,
        authorization,
        documentId,
        options
      )(fetch, basePath)
    },
    /**
     * Generates proofs for the fields from a specific document version.
     * @summary Generates proofs for the fields from a specific document version.
     * @param {CoreapiProofsRequest} body Document proof request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocumentVersionProofs(
      body: CoreapiProofsRequest,
      authorization: string,
      documentId: string,
      versionId: string,
      options?: any
    ) {
      return DocumentsApiFp(configuration).generateDocumentVersionProofs(
        body,
        authorization,
        documentId,
        versionId,
        options
      )(fetch, basePath)
    },
    /**
     * Returns the latest committed document associated with docID.
     * @summary Returns the latest committed document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittedDocument(authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).getCommittedDocument(authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Returns the specific version of the document.
     * @summary Returns the specific version of the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} versionId Document Version Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocumentVersionV2(authorization: string, documentId: string, versionId: string, options?: any) {
      return DocumentsApiFp(configuration).getDocumentVersionV2(
        authorization,
        documentId,
        versionId,
        options
      )(fetch, basePath)
    },
    /**
     * Returns the entity relationships.
     * @summary Returns the entity relationships.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityRelationships(authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).getEntityRelationships(authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Returns the latest version of the Entity through relationship ID.
     * @summary Returns the latest version of the Entity through relationship ID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Entity Relationship Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityThroughRelationshipId(authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).getEntityThroughRelationshipId(
        authorization,
        documentId,
        options
      )(fetch, basePath)
    },
    /**
     * Returns the pending document associated with docID.
     * @summary Returns the pending document associated with docID.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPendingDocument(authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).getPendingDocument(authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Returns the role associated with the role ID in the document.
     * @summary Returns the role associated with the role ID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(authorization: string, documentId: string, roleId: string, options?: any) {
      return DocumentsApiFp(configuration).getRole(authorization, documentId, roleId, options)(fetch, basePath)
    },
    /**
     * Returns the rule associated with the ruleID in the document.
     * @summary Returns the rule associated with the ruleID in the document.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} ruleId Transition rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransitionRule(authorization: string, documentId: string, ruleId: string, options?: any) {
      return DocumentsApiFp(configuration).getTransitionRule(
        authorization,
        documentId,
        ruleId,
        options
      )(fetch, basePath)
    },
    /**
     * Removes the collaborators from the document.
     * @summary Removes the collaborators from the document.
     * @param {V2RemoveCollaboratorsRequest} body Remove Collaborators request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCollaborators(body: V2RemoveCollaboratorsRequest, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).removeCollaborators(
        body,
        authorization,
        documentId,
        options
      )(fetch, basePath)
    },
    /**
     * Updates a pending document.
     * @summary Updates a pending document.
     * @param {V2UpdateDocumentRequest} body Document Update request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDocumentV2(body: V2UpdateDocumentRequest, authorization: string, documentId: string, options?: any) {
      return DocumentsApiFp(configuration).updateDocumentV2(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Updates an existing role on the document.
     * @summary Updates an existing role on the document.
     * @param {V2UpdateRole} body Update Role Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {string} roleId Role ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(body: V2UpdateRole, authorization: string, documentId: string, roleId: string, options?: any) {
      return DocumentsApiFp(configuration).updateRole(body, authorization, documentId, roleId, options)(fetch, basePath)
    },
  }
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
  /**
   * Add attributes to pending document.
   * @summary Add attributes to pending document.
   * @param {{ [key: string]: CoreapiAttributeRequest; }} body Attributes
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public addAttributes(
    body: { [key: string]: CoreapiAttributeRequest },
    authorization: string,
    documentId: string,
    options?: any
  ) {
    return DocumentsApiFp(this.configuration).addAttributes(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Adds a new role to the document.
   * @summary Adds a new role to the document.
   * @param {V2AddRole} body Add Role Request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public addRole(body: V2AddRole, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).addRole(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Signs the given payload and add it the pending document.
   * @summary Signs the given payload and add it the pending document.
   * @param {V2SignedAttributeRequest} body Signed Attribute request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public addSignedAttribute(body: V2SignedAttributeRequest, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).addSignedAttribute(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Adds a new transition rules to the document.
   * @summary Adds a transition new rules to the document.
   * @param {PendingAddTransitionRules} body Add Transition rules Request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public addTransitionRule(body: PendingAddTransitionRules, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).addTransitionRule(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Creates a new cloned document from an existing Template document.
   * @summary Creates a new cloned document from an existing Template document.
   * @param {V2CloneDocumentRequest} body Document Clone request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public cloneDocumentV2(body: V2CloneDocumentRequest, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).cloneDocumentV2(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Commits a pending document.
   * @summary Commits a pending document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public commitDocumentV2(authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).commitDocumentV2(
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Creates a new document.
   * @summary Creates a new document.
   * @param {V2CreateDocumentRequest} body Document Create request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public createDocumentV2(body: V2CreateDocumentRequest, authorization: string, options?: any) {
    return DocumentsApiFp(this.configuration).createDocumentV2(body, authorization, options)(this.fetch, this.basePath)
  }

  /**
   * Deletes attribute on a pending document.
   * @summary Deletes attribute on a pending document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} attributeKey Hex encoded attribute key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public deleteAttribute(authorization: string, documentId: string, attributeKey: string, options?: any) {
    return DocumentsApiFp(this.configuration).deleteAttribute(
      authorization,
      documentId,
      attributeKey,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Deletes the transition rule associated with ruleID from the document.
   * @summary Deletes the transition rule associated with ruleID from the document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} ruleId Transition rule ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public deleteTransitionRule(authorization: string, documentId: string, ruleId: string, options?: any) {
    return DocumentsApiFp(this.configuration).deleteTransitionRule(
      authorization,
      documentId,
      ruleId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Generates proofs for the fields from latest version of the document.
   * @summary Generates proofs for the fields from latest version of the document.
   * @param {CoreapiProofsRequest} body Document proof request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public generateDocumentProofs(body: CoreapiProofsRequest, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).generateDocumentProofs(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Generates proofs for the fields from a specific document version.
   * @summary Generates proofs for the fields from a specific document version.
   * @param {CoreapiProofsRequest} body Document proof request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} versionId Document Version Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public generateDocumentVersionProofs(
    body: CoreapiProofsRequest,
    authorization: string,
    documentId: string,
    versionId: string,
    options?: any
  ) {
    return DocumentsApiFp(this.configuration).generateDocumentVersionProofs(
      body,
      authorization,
      documentId,
      versionId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the latest committed document associated with docID.
   * @summary Returns the latest committed document associated with docID.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getCommittedDocument(authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getCommittedDocument(
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the specific version of the document.
   * @summary Returns the specific version of the document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} versionId Document Version Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getDocumentVersionV2(authorization: string, documentId: string, versionId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getDocumentVersionV2(
      authorization,
      documentId,
      versionId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the entity relationships.
   * @summary Returns the entity relationships.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getEntityRelationships(authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getEntityRelationships(
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the latest version of the Entity through relationship ID.
   * @summary Returns the latest version of the Entity through relationship ID.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Entity Relationship Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getEntityThroughRelationshipId(authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getEntityThroughRelationshipId(
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the pending document associated with docID.
   * @summary Returns the pending document associated with docID.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getPendingDocument(authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getPendingDocument(
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the role associated with the role ID in the document.
   * @summary Returns the role associated with the role ID in the document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} roleId Role ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getRole(authorization: string, documentId: string, roleId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getRole(
      authorization,
      documentId,
      roleId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the rule associated with the ruleID in the document.
   * @summary Returns the rule associated with the ruleID in the document.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} ruleId Transition rule ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getTransitionRule(authorization: string, documentId: string, ruleId: string, options?: any) {
    return DocumentsApiFp(this.configuration).getTransitionRule(
      authorization,
      documentId,
      ruleId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Removes the collaborators from the document.
   * @summary Removes the collaborators from the document.
   * @param {V2RemoveCollaboratorsRequest} body Remove Collaborators request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public removeCollaborators(
    body: V2RemoveCollaboratorsRequest,
    authorization: string,
    documentId: string,
    options?: any
  ) {
    return DocumentsApiFp(this.configuration).removeCollaborators(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Updates a pending document.
   * @summary Updates a pending document.
   * @param {V2UpdateDocumentRequest} body Document Update request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public updateDocumentV2(body: V2UpdateDocumentRequest, authorization: string, documentId: string, options?: any) {
    return DocumentsApiFp(this.configuration).updateDocumentV2(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Updates an existing role on the document.
   * @summary Updates an existing role on the document.
   * @param {V2UpdateRole} body Update Role Request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {string} roleId Role ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public updateRole(body: V2UpdateRole, authorization: string, documentId: string, roleId: string, options?: any) {
    return DocumentsApiFp(this.configuration).updateRole(
      body,
      authorization,
      documentId,
      roleId,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * HealthApi - fetch parameter creator
 * @export
 */
export const HealthApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * returns node version and network
     * @summary Health check for Node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options: any = {}): FetchArgs {
      const localVarPath = `/ping`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * returns node version and network
     * @summary Health check for Node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HealthPong> {
      const localVarFetchArgs = HealthApiFetchParamCreator(configuration).ping(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * returns node version and network
     * @summary Health check for Node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any) {
      return HealthApiFp(configuration).ping(options)(fetch, basePath)
    },
  }
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * returns node version and network
   * @summary Health check for Node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: any) {
    return HealthApiFp(this.configuration).ping(options)(this.fetch, this.basePath)
  }
}
/**
 * JobsApi - fetch parameter creator
 * @export
 */
export const JobsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the details of a given Job.
     * @summary Returns the details of a given Job.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} jobId Hex encoded Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob(authorization: string, jobId: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling getJob.'
        )
      }
      // verify required parameter 'jobId' is not null or undefined
      if (jobId === null || jobId === undefined) {
        throw new RequiredError('jobId', 'Required parameter jobId was null or undefined when calling getJob.')
      }
      const localVarPath = `/v2/jobs/{job_id}`.replace(`{${'job_id'}}`, encodeURIComponent(String(jobId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the details of a given Job.
     * @summary Returns the details of a given Job.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} jobId Hex encoded Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob(
      authorization: string,
      jobId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<V2Job> {
      const localVarFetchArgs = JobsApiFetchParamCreator(configuration).getJob(authorization, jobId, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Returns the details of a given Job.
     * @summary Returns the details of a given Job.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} jobId Hex encoded Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJob(authorization: string, jobId: string, options?: any) {
      return JobsApiFp(configuration).getJob(authorization, jobId, options)(fetch, basePath)
    },
  }
}

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
  /**
   * Returns the details of a given Job.
   * @summary Returns the details of a given Job.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} jobId Hex encoded Job ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobsApi
   */
  public getJob(authorization: string, jobId: string, options?: any) {
    return JobsApiFp(this.configuration).getJob(authorization, jobId, options)(this.fetch, this.basePath)
  }
}
/**
 * NFTsApi - fetch parameter creator
 * @export
 */
export const NFTsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Mints an NFT against a document.
     * @summary Mints an NFT against a document.
     * @param {CoreapiMintNFTRequest} body Mint NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(body: CoreapiMintNFTRequest, authorization: string, registryAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling mintNft.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling mintNft.'
        )
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling mintNft.'
        )
      }
      const localVarPath = `/v2/nfts/registries/{registry_address}/mint`.replace(
        `{${'registry_address'}}`,
        encodeURIComponent(String(registryAddress))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiMintNFTRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Mints an NFT against a document on centrifuge chain.
     * @summary Mints an NFT against a document on centrifuge chain.
     * @param {CoreapiMintNFTOnCCRequest} body Mint NFT on CC request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNftCc(
      body: CoreapiMintNFTOnCCRequest,
      authorization: string,
      registryAddress: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling mintNftCc.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling mintNftCc.'
        )
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling mintNftCc.'
        )
      }
      const localVarPath = `/beta/nfts/registries/{registry_address}/mint`.replace(
        `{${'registry_address'}}`,
        encodeURIComponent(String(registryAddress))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiMintNFTOnCCRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the Owner of the given NFT.
     * @summary Returns the Owner of the given NFT.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNft(authorization: string, tokenId: string, registryAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling ownerOfNft.'
        )
      }
      // verify required parameter 'tokenId' is not null or undefined
      if (tokenId === null || tokenId === undefined) {
        throw new RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling ownerOfNft.')
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling ownerOfNft.'
        )
      }
      const localVarPath = `/v2/nfts/registries/{registry_address}/tokens/{token_id}/owner`
        .replace(`{${'token_id'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'registry_address'}}`, encodeURIComponent(String(registryAddress)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the Owner of the given NFT on centrifuge chain.
     * @summary Returns the Owner of the given NFT on centrifuge chain.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNftCc(authorization: string, tokenId: string, registryAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling ownerOfNftCc.'
        )
      }
      // verify required parameter 'tokenId' is not null or undefined
      if (tokenId === null || tokenId === undefined) {
        throw new RequiredError(
          'tokenId',
          'Required parameter tokenId was null or undefined when calling ownerOfNftCc.'
        )
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling ownerOfNftCc.'
        )
      }
      const localVarPath = `/beta/nfts/registries/{registry_address}/tokens/{token_id}/owner`
        .replace(`{${'token_id'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'registry_address'}}`, encodeURIComponent(String(registryAddress)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pushes a given attribute value to oracle.
     * @summary Pushes a given attribute value to oracle.
     * @param {OraclePushAttributeToOracleRequest} body Push Attribute to Oracle Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushAttributeOracle(
      body: OraclePushAttributeToOracleRequest,
      authorization: string,
      documentId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling pushAttributeOracle.'
        )
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling pushAttributeOracle.'
        )
      }
      // verify required parameter 'documentId' is not null or undefined
      if (documentId === null || documentId === undefined) {
        throw new RequiredError(
          'documentId',
          'Required parameter documentId was null or undefined when calling pushAttributeOracle.'
        )
      }
      const localVarPath = `/v2/documents/{document_id}/push_to_oracle`.replace(
        `{${'document_id'}}`,
        encodeURIComponent(String(documentId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'OraclePushAttributeToOracleRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Transfers given NFT to provide address.
     * @summary Transfers given NFT to provide address.
     * @param {CoreapiTransferNFTRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNft(
      body: CoreapiTransferNFTRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transferNft.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling transferNft.'
        )
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling transferNft.'
        )
      }
      // verify required parameter 'tokenId' is not null or undefined
      if (tokenId === null || tokenId === undefined) {
        throw new RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling transferNft.')
      }
      const localVarPath = `/v2/nfts/registries/{registry_address}/tokens/{token_id}/transfer`
        .replace(`{${'registry_address'}}`, encodeURIComponent(String(registryAddress)))
        .replace(`{${'token_id'}}`, encodeURIComponent(String(tokenId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiTransferNFTRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Transfers given NFT to provide address on centrifuge chain.
     * @summary Transfers given NFT to provide address on centrifuge chain.
     * @param {CoreapiTransferNFTOnCCRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNftCc(
      body: CoreapiTransferNFTOnCCRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling transferNftCc.')
      }
      // verify required parameter 'authorization' is not null or undefined
      if (authorization === null || authorization === undefined) {
        throw new RequiredError(
          'authorization',
          'Required parameter authorization was null or undefined when calling transferNftCc.'
        )
      }
      // verify required parameter 'registryAddress' is not null or undefined
      if (registryAddress === null || registryAddress === undefined) {
        throw new RequiredError(
          'registryAddress',
          'Required parameter registryAddress was null or undefined when calling transferNftCc.'
        )
      }
      // verify required parameter 'tokenId' is not null or undefined
      if (tokenId === null || tokenId === undefined) {
        throw new RequiredError(
          'tokenId',
          'Required parameter tokenId was null or undefined when calling transferNftCc.'
        )
      }
      const localVarPath = `/beta/nfts/registries/{registry_address}/tokens/{token_id}/transfer`
        .replace(`{${'registry_address'}}`, encodeURIComponent(String(registryAddress)))
        .replace(`{${'token_id'}}`, encodeURIComponent(String(tokenId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'CoreapiTransferNFTOnCCRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NFTsApi - functional programming interface
 * @export
 */
export const NFTsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Mints an NFT against a document.
     * @summary Mints an NFT against a document.
     * @param {CoreapiMintNFTRequest} body Mint NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(
      body: CoreapiMintNFTRequest,
      authorization: string,
      registryAddress: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiMintNFTResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).mintNft(
        body,
        authorization,
        registryAddress,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Mints an NFT against a document on centrifuge chain.
     * @summary Mints an NFT against a document on centrifuge chain.
     * @param {CoreapiMintNFTOnCCRequest} body Mint NFT on CC request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNftCc(
      body: CoreapiMintNFTOnCCRequest,
      authorization: string,
      registryAddress: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiMintNFTOnCCResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).mintNftCc(
        body,
        authorization,
        registryAddress,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the Owner of the given NFT.
     * @summary Returns the Owner of the given NFT.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNft(
      authorization: string,
      tokenId: string,
      registryAddress: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiNFTOwnerResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).ownerOfNft(
        authorization,
        tokenId,
        registryAddress,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Returns the Owner of the given NFT on centrifuge chain.
     * @summary Returns the Owner of the given NFT on centrifuge chain.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNftCc(
      authorization: string,
      tokenId: string,
      registryAddress: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiNFTOwnerOnCCResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).ownerOfNftCc(
        authorization,
        tokenId,
        registryAddress,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Pushes a given attribute value to oracle.
     * @summary Pushes a given attribute value to oracle.
     * @param {OraclePushAttributeToOracleRequest} body Push Attribute to Oracle Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushAttributeOracle(
      body: OraclePushAttributeToOracleRequest,
      authorization: string,
      documentId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OraclePushToOracleResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).pushAttributeOracle(
        body,
        authorization,
        documentId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Transfers given NFT to provide address.
     * @summary Transfers given NFT to provide address.
     * @param {CoreapiTransferNFTRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNft(
      body: CoreapiTransferNFTRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiTransferNFTResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).transferNft(
        body,
        authorization,
        registryAddress,
        tokenId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Transfers given NFT to provide address on centrifuge chain.
     * @summary Transfers given NFT to provide address on centrifuge chain.
     * @param {CoreapiTransferNFTOnCCRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNftCc(
      body: CoreapiTransferNFTOnCCRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoreapiTransferNFTOnCCResponse> {
      const localVarFetchArgs = NFTsApiFetchParamCreator(configuration).transferNftCc(
        body,
        authorization,
        registryAddress,
        tokenId,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * NFTsApi - factory interface
 * @export
 */
export const NFTsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Mints an NFT against a document.
     * @summary Mints an NFT against a document.
     * @param {CoreapiMintNFTRequest} body Mint NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNft(body: CoreapiMintNFTRequest, authorization: string, registryAddress: string, options?: any) {
      return NFTsApiFp(configuration).mintNft(body, authorization, registryAddress, options)(fetch, basePath)
    },
    /**
     * Mints an NFT against a document on centrifuge chain.
     * @summary Mints an NFT against a document on centrifuge chain.
     * @param {CoreapiMintNFTOnCCRequest} body Mint NFT on CC request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintNftCc(body: CoreapiMintNFTOnCCRequest, authorization: string, registryAddress: string, options?: any) {
      return NFTsApiFp(configuration).mintNftCc(body, authorization, registryAddress, options)(fetch, basePath)
    },
    /**
     * Returns the Owner of the given NFT.
     * @summary Returns the Owner of the given NFT.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNft(authorization: string, tokenId: string, registryAddress: string, options?: any) {
      return NFTsApiFp(configuration).ownerOfNft(authorization, tokenId, registryAddress, options)(fetch, basePath)
    },
    /**
     * Returns the Owner of the given NFT on centrifuge chain.
     * @summary Returns the Owner of the given NFT on centrifuge chain.
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} tokenId NFT token ID in hex
     * @param {string} registryAddress Registry address in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ownerOfNftCc(authorization: string, tokenId: string, registryAddress: string, options?: any) {
      return NFTsApiFp(configuration).ownerOfNftCc(authorization, tokenId, registryAddress, options)(fetch, basePath)
    },
    /**
     * Pushes a given attribute value to oracle.
     * @summary Pushes a given attribute value to oracle.
     * @param {OraclePushAttributeToOracleRequest} body Push Attribute to Oracle Request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} documentId Document Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushAttributeOracle(
      body: OraclePushAttributeToOracleRequest,
      authorization: string,
      documentId: string,
      options?: any
    ) {
      return NFTsApiFp(configuration).pushAttributeOracle(body, authorization, documentId, options)(fetch, basePath)
    },
    /**
     * Transfers given NFT to provide address.
     * @summary Transfers given NFT to provide address.
     * @param {CoreapiTransferNFTRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNft(
      body: CoreapiTransferNFTRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options?: any
    ) {
      return NFTsApiFp(configuration).transferNft(
        body,
        authorization,
        registryAddress,
        tokenId,
        options
      )(fetch, basePath)
    },
    /**
     * Transfers given NFT to provide address on centrifuge chain.
     * @summary Transfers given NFT to provide address on centrifuge chain.
     * @param {CoreapiTransferNFTOnCCRequest} body Transfer NFT request
     * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
     * @param {string} registryAddress NFT registry address in hex
     * @param {string} tokenId NFT token ID in hex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferNftCc(
      body: CoreapiTransferNFTOnCCRequest,
      authorization: string,
      registryAddress: string,
      tokenId: string,
      options?: any
    ) {
      return NFTsApiFp(configuration).transferNftCc(
        body,
        authorization,
        registryAddress,
        tokenId,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * NFTsApi - object-oriented interface
 * @export
 * @class NFTsApi
 * @extends {BaseAPI}
 */
export class NFTsApi extends BaseAPI {
  /**
   * Mints an NFT against a document.
   * @summary Mints an NFT against a document.
   * @param {CoreapiMintNFTRequest} body Mint NFT request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} registryAddress NFT registry address in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public mintNft(body: CoreapiMintNFTRequest, authorization: string, registryAddress: string, options?: any) {
    return NFTsApiFp(this.configuration).mintNft(
      body,
      authorization,
      registryAddress,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Mints an NFT against a document on centrifuge chain.
   * @summary Mints an NFT against a document on centrifuge chain.
   * @param {CoreapiMintNFTOnCCRequest} body Mint NFT on CC request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} registryAddress NFT registry address in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public mintNftCc(body: CoreapiMintNFTOnCCRequest, authorization: string, registryAddress: string, options?: any) {
    return NFTsApiFp(this.configuration).mintNftCc(
      body,
      authorization,
      registryAddress,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the Owner of the given NFT.
   * @summary Returns the Owner of the given NFT.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} tokenId NFT token ID in hex
   * @param {string} registryAddress Registry address in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public ownerOfNft(authorization: string, tokenId: string, registryAddress: string, options?: any) {
    return NFTsApiFp(this.configuration).ownerOfNft(
      authorization,
      tokenId,
      registryAddress,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Returns the Owner of the given NFT on centrifuge chain.
   * @summary Returns the Owner of the given NFT on centrifuge chain.
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} tokenId NFT token ID in hex
   * @param {string} registryAddress Registry address in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public ownerOfNftCc(authorization: string, tokenId: string, registryAddress: string, options?: any) {
    return NFTsApiFp(this.configuration).ownerOfNftCc(
      authorization,
      tokenId,
      registryAddress,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Pushes a given attribute value to oracle.
   * @summary Pushes a given attribute value to oracle.
   * @param {OraclePushAttributeToOracleRequest} body Push Attribute to Oracle Request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} documentId Document Identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public pushAttributeOracle(
    body: OraclePushAttributeToOracleRequest,
    authorization: string,
    documentId: string,
    options?: any
  ) {
    return NFTsApiFp(this.configuration).pushAttributeOracle(
      body,
      authorization,
      documentId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Transfers given NFT to provide address.
   * @summary Transfers given NFT to provide address.
   * @param {CoreapiTransferNFTRequest} body Transfer NFT request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} registryAddress NFT registry address in hex
   * @param {string} tokenId NFT token ID in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public transferNft(
    body: CoreapiTransferNFTRequest,
    authorization: string,
    registryAddress: string,
    tokenId: string,
    options?: any
  ) {
    return NFTsApiFp(this.configuration).transferNft(
      body,
      authorization,
      registryAddress,
      tokenId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Transfers given NFT to provide address on centrifuge chain.
   * @summary Transfers given NFT to provide address on centrifuge chain.
   * @param {CoreapiTransferNFTOnCCRequest} body Transfer NFT request
   * @param {string} authorization Hex encoded centrifuge ID of the account for the intended API action
   * @param {string} registryAddress NFT registry address in hex
   * @param {string} tokenId NFT token ID in hex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NFTsApi
   */
  public transferNftCc(
    body: CoreapiTransferNFTOnCCRequest,
    authorization: string,
    registryAddress: string,
    tokenId: string,
    options?: any
  ) {
    return NFTsApiFp(this.configuration).transferNftCc(
      body,
      authorization,
      registryAddress,
      tokenId,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * WebhookApi - fetch parameter creator
 * @export
 */
export const WebhookApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Webhook is a place holder to describe webhook response in swagger.
     * @summary Webhook is a place holder to describe webhook response in swagger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook(options: any = {}): FetchArgs {
      const localVarPath = `/webhook`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Webhook is a place holder to describe webhook response in swagger.
     * @summary Webhook is a place holder to describe webhook response in swagger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationMessage> {
      const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).webhook(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Webhook is a place holder to describe webhook response in swagger.
     * @summary Webhook is a place holder to describe webhook response in swagger.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhook(options?: any) {
      return WebhookApiFp(configuration).webhook(options)(fetch, basePath)
    },
  }
}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
  /**
   * Webhook is a place holder to describe webhook response in swagger.
   * @summary Webhook is a place holder to describe webhook response in swagger.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookApi
   */
  public webhook(options?: any) {
    return WebhookApiFp(this.configuration).webhook(options)(this.fetch, this.basePath)
  }
}
